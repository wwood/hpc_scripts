#!/usr/bin/env python3
"""Interactive job viewer similar to ``htop``.

This tool combines running and recently finished jobs into a single table
and allows selecting rows to inspect job logs.
"""

import argparse
import importlib.util
import os
import re
import subprocess
import time
import unicodedata
from importlib.machinery import SourceFileLoader

import curses


def _load_script(name):
    """Load a script from ``bin`` as a module."""

    path = os.path.join(os.path.dirname(__file__), name)
    loader = SourceFileLoader(f"{name}_module", path)
    spec = importlib.util.spec_from_loader(f"{name}_module", loader)
    mod = importlib.util.module_from_spec(spec)
    loader.exec_module(mod)
    return mod


mqstat = _load_script("mqstat")
mqsub = _load_script("mqsub")


ansi_re = re.compile(r"\x1b\[(\d+)m(.*?)\x1b\[0m")
# basic ANSI colour escapes used for row colouring
ORANGE = "\033[33m"

# Automatically refresh the job table every 10 minutes (in seconds)
REFRESH_INTERVAL = 10 * 60


def grafana_url(job_id: str) -> str:
    """Return Grafana dashboard URL for *job_id*.

    ``job_id`` may include a suffix such as ``.aqua`` which will be
    stripped before constructing the URL.
    """

    numeric = str(job_id).split(".")[0]
    return (
        "https://hpc-monitoring.eres.qut.edu.au/d/pbs-public-job/pbs-job?var-jobid="
        + numeric
    )


def refresh_due(last_refresh: float, now: float | None = None, interval: int = REFRESH_INTERVAL) -> bool:
    """Return ``True`` if a refresh should occur.

    Parameters
    ----------
    last_refresh:
        Timestamp of the most recent refresh.
    now:
        Current timestamp. Defaults to ``time.time()``.
    interval:
        Refresh interval in seconds. Defaults to :data:`REFRESH_INTERVAL`.
    """

    if now is None:
        now = time.time()
    return now - last_refresh >= interval


def strip_ansi(text: str) -> str:
    """Return *text* with ANSI colour escapes removed."""

    return ansi_re.sub(r"\2", text)


def visible_len(text: str) -> int:
    """Length of *text* ignoring ANSI colour escapes."""

    return len(strip_ansi(text))


def ljust_ansi(text: str, width: int) -> str:
    pad = max(width - visible_len(text), 0)
    return text + " " * pad


def rjust_ansi(text: str, width: int) -> str:
    pad = max(width - visible_len(text), 0)
    return " " * pad + text


def _width(ch):
    if unicodedata.combining(ch):
        return 0
    return 2 if unicodedata.east_asian_width(ch) in ("F", "W") else 1


def addstr_safe(stdscr, y, x, text, maxx, attr=0):
    width = 0
    out = []
    for ch in text:
        w = _width(ch)
        if x + width + w > maxx - 1:
            break
        out.append(ch)
        width += w
    if out:
        try:
            stdscr.addstr(y, x, "".join(out), attr)
        except curses.error:
            pass
    return width


def draw_line(stdscr, y, line, maxx, highlight=False):
    """Draw a line that may contain ANSI colour escape codes."""

    x = 0
    last = 0
    attr = curses.A_REVERSE if highlight else 0
    for match in ansi_re.finditer(line):
        x += addstr_safe(stdscr, y, x, line[last:match.start()], maxx, attr)
        colour = match.group(1)
        pair = {"92": 1, "91": 2, "93": 3, "33": 4}.get(colour, 0)
        colour_pair = curses.color_pair(pair)
        x += addstr_safe(stdscr, y, x, match.group(2), maxx, colour_pair | attr)
        last = match.end()
        if x >= maxx - 1:
            break
    if x < maxx - 1 and last < len(line):
        addstr_safe(stdscr, y, x, line[last:], maxx, attr)


def format_jobs(jobs, now=None):
    """Return formatted job table lines and corresponding job objects."""

    if now is None:
        now = time.time()

    rows = []
    headers = [
        "job_id",
        "name",
        "time used",
        "progress",
        "walltime",
        "waited",
        "age",
        "CPU",
        "cpu%",
        "RAM(G)",
        "ram%",
        "state",
        "queue",
        "note",
    ]

    for job in jobs:
        if job.get("queue") == "cpu_inter_exec":
            continue
        queue = job.get("queue", "").replace("_batch_exec", "")
        job_id = job.get("id", "")
        name = job.get("name", "")
        used_s = job.get("walltime_used", 0)
        total_s = job.get("walltime_total", job.get("walltime", 0))
        used = mqstat.format_hm(used_s)
        total = mqstat.format_hm(total_s)
        bar = mqstat.progress_bar(used_s, total_s)
        waited = ""
        qtime = job.get("qtime")
        start_time = job.get("start_time")
        state = job.get("state", "")
        if state == "Q" and qtime:
            waited = mqstat.format_hm(max(0, now - qtime))
        elif qtime and start_time:
            waited = mqstat.format_hm(max(0, start_time - qtime))

        age = ""
        if state in ("C", "F"):
            ft = job.get("obittime") or job.get("mtime")
            if ft:
                age = mqstat.format_hm(max(0, int(now - ft)))

        cpu = job.get("ncpus", 0)
        cpupercent = job.get("cpupercent")
        ncpus_used = job.get("ncpus_used", cpu)
        cpu_util = 0
        if job.get("state") in ("C", "F"):
            cput_used = job.get("cput_used", 0)
            if used_s and cpu:
                cpu_util = cput_used / (used_s * cpu) * 100
        elif cpupercent is not None and ncpus_used:
            cpu_util = cpupercent / ncpus_used
        cpu_util_str = f"{int(cpu_util)}%" if cpu_util else ""
        cpu_low = cpu_util and cpu_util < 10
        short_run = used_s <= 120

        ram = int(job.get("mem_request_gb", 0))
        vmem_kb = job.get("vmem_used_kb") or job.get("mem_usage", 0)
        ram_util = (vmem_kb / (ram * 1024 * 1024) * 100) if ram else 0
        ram_util_str = f"{int(ram_util)}%" if ram_util else ""
        ram_low = ram_util and ram_util < 10

        note = ""
        if state not in ("C", "F"):
            if (
                not short_run
                and cpupercent is not None
                and ncpus_used
                and cpupercent < ncpus_used * 10
            ):
                note = "â— <10% of CPU used"
        else:
            if used_s < 60:
                note = "short"
            elif cpu_low and ram_low:
                note = "<10% CPU, <10% RAM"
            elif cpu_low:
                note = "<10% CPU"
            elif ram_low:
                note = "<10% RAM"
            if job.get("exit_status", 0) != 0:
                note = "!" + note

        cpu_field = (
            mqstat.Colors.RED + cpu_util_str + mqstat.Colors.ENDC
            if cpu_low and not short_run
            else cpu_util_str
        )
        ram_field = (
            mqstat.Colors.RED + ram_util_str + mqstat.Colors.ENDC
            if ram_low and not short_run
            else ram_util_str
        )

        row_color = ""
        if state == "Q":
            row_color = mqstat.Colors.YELLOW
        elif state in ("C", "F"):
            row_color = (
                mqstat.Colors.GREEN
                if job.get("exit_status", 0) == 0
                else mqstat.Colors.RED
            )
        elif state != "R":
            row_color = ORANGE

        rows.append(
            {
                "job_id": job_id,
                "name": name,
                "used": used,
                "bar": bar,
                "wall": total,
                "waited": waited,
                "age": age,
                "cpu": str(cpu),
                "cpu_util": cpu_field,
                "ram": str(ram),
                "ram_util": ram_field,
                "state": state,
                "queue": queue,
                "note": note,
                "raw": job,
                "row_color": row_color,
            }
        )

    if not rows:
        return ["  ".join(headers)], []

    id_w = max(len(headers[0]), max(visible_len(r["job_id"]) for r in rows))
    name_w = max(len(headers[1]), max(visible_len(r["name"]) for r in rows))
    time_w = len(headers[2])
    wall_w = max(len(headers[4]), max(visible_len(r["wall"]) for r in rows))
    wait_w = max(len(headers[5]), max(visible_len(r["waited"]) for r in rows))
    age_w = max(len(headers[6]), max(visible_len(r["age"]) for r in rows))
    cpu_w = max(len(headers[7]), max(visible_len(r["cpu"]) for r in rows))
    cpuu_w = max(len(headers[8]), max(visible_len(r["cpu_util"]) for r in rows))
    ram_w = max(len(headers[9]), max(visible_len(r["ram"]) for r in rows))
    ramu_w = max(len(headers[10]), max(visible_len(r["ram_util"]) for r in rows))
    state_w = max(len(headers[11]), max(visible_len(r["state"]) for r in rows))
    queue_w = max(len(headers[12]), max(visible_len(r["queue"]) for r in rows))
    note_w = max(len(headers[13]), max(visible_len(r["note"]) for r in rows))

    header_parts = [
        headers[0].ljust(id_w),
        headers[1].ljust(name_w),
        headers[2].ljust(time_w),
        headers[3].ljust(20),
        headers[4].ljust(wall_w),
        headers[5].ljust(wait_w),
        headers[6].ljust(age_w),
        headers[7].rjust(cpu_w),
        headers[8].rjust(cpuu_w),
        headers[9].rjust(ram_w),
        headers[10].rjust(ramu_w),
        headers[11].ljust(state_w),
        headers[12].ljust(queue_w),
        headers[13].ljust(note_w),
    ]
    lines = ["  ".join(header_parts)]

    for r in rows:
        parts = [
            ljust_ansi(r["job_id"], id_w),
            ljust_ansi(r["name"], name_w),
            ljust_ansi(r["used"], time_w),
            r["bar"],
            ljust_ansi(r["wall"], wall_w),
            ljust_ansi(r["waited"], wait_w),
            ljust_ansi(r["age"], age_w),
            rjust_ansi(r["cpu"], cpu_w),
            rjust_ansi(r["cpu_util"], cpuu_w),
            rjust_ansi(r["ram"], ram_w),
            rjust_ansi(r["ram_util"], ramu_w),
            ljust_ansi(r["state"], state_w),
            ljust_ansi(r["queue"], queue_w),
            ljust_ansi(r["note"], note_w),
        ]
        coloured_parts = []
        row_colour = r.get("row_color", "")
        for idx, part in enumerate(parts):
            if idx == 3:  # progress column
                coloured_parts.append(part)
            elif row_colour and not ansi_re.search(part):
                coloured_parts.append(row_colour + part + mqstat.Colors.ENDC)
            else:
                coloured_parts.append(part)
        lines.append("  ".join(coloured_parts))

    jobs_out = [r["raw"] for r in rows]
    return lines, jobs_out


def main() -> None:
    parser = argparse.ArgumentParser(description="Interactive job viewer")
    parser.add_argument("--qstat-f-file", help="Use qstat -f output from file", default=None)
    parser.add_argument("--qstat-xf-file", help="Use qstat -xf output from file", default=None)
    parser.add_argument("--qstat-file", help=argparse.SUPPRESS, default=None)
    parser.add_argument(
        "--max-jobs",
        type=int,
        default=1000,
        help="Maximum number of jobs to load",
    )
    parser.add_argument(
        "--print-first-page",
        action="store_true",
        help="Print first page of job table to stdout and exit",
    )
    args = parser.parse_args()

    if args.qstat_file and not args.qstat_f_file:
        args.qstat_f_file = args.qstat_file

    def get_jobs(include_history: bool = False):
        if args.qstat_f_file or args.qstat_xf_file:
            active = mqstat.parse_qstat(path=args.qstat_f_file) if args.qstat_f_file else []
            hist = mqstat.parse_qstat(path=args.qstat_xf_file) if args.qstat_xf_file else []
            job_dict = {j["id"]: j for j in active}
            for job in hist:
                job_dict.setdefault(job["id"], job)
            return list(job_dict.values())
        return mqstat.parse_qstat(
            include_history=include_history,
            max_jobs=args.max_jobs,
        )

    if args.print_first_page:
        jobs = get_jobs(include_history=True)
        now = time.time()
        finished = {}
        running = []
        queued = []
        for job in jobs:
            if job.get("queue") == "cpu_inter_exec":
                continue
            state = job.get("state")
            if state in ("C", "F"):
                finished[job["id"]] = job
            elif state == "Q":
                queued.append(job)
            else:
                running.append(job)
        if running or queued:
            for jid, job in list(finished.items()):
                ft = job.get("obittime") or job.get("mtime", now)
                if now - ft > 24 * 3600:
                    finished.pop(jid, None)
        running.sort(key=lambda j: j.get("walltime_used", 0), reverse=True)
        queued.sort(key=lambda j: now - j.get("qtime", now), reverse=True)
        finished_jobs = sorted(
            finished.values(), key=lambda j: j.get("obittime") or j.get("mtime", 0), reverse=True
        )
        all_jobs = running + queued + finished_jobs
        lines, _ = format_jobs(all_jobs, now=now)
        for line in lines[:24]:
            print(line)
        return

    def _draw(stdscr):
        curses.curs_set(0)
        curses.start_color()
        curses.use_default_colors()
        curses.init_pair(1, curses.COLOR_GREEN, -1)
        curses.init_pair(2, curses.COLOR_RED, -1)
        curses.init_pair(3, curses.COLOR_YELLOW, -1)
        if getattr(curses, "COLORS", 8) > 208:
            try:
                curses.init_pair(4, 208, -1)  # orange if terminal supports it
            except (curses.error, ValueError):
                curses.init_pair(4, curses.COLOR_YELLOW, -1)
        else:
            curses.init_pair(4, curses.COLOR_YELLOW, -1)
        stdscr.nodelay(True)
        stdscr.keypad(True)
        curses.mousemask(curses.BUTTON1_CLICKED)

        finished = {}
        selected = 1  # absolute selected row index (1..)
        offset = 0  # topmost job line displayed (0-based)
        lines, job_rows = [], []
        refresh = True
        show_queued = True
        last_refresh = 0.0
        user_warning = None
        user_warn_until = 0.0

        while True:
            maxy, maxx = stdscr.getmaxyx()
            key = stdscr.getch()
            if user_warning and time.time() > user_warn_until:
                user_warning = None
            if refresh_due(last_refresh):
                refresh = True

            if key == ord("q"):
                break
            elif key == curses.KEY_MOUSE:
                try:
                    _, _, my, _, _ = curses.getmouse()
                except curses.error:
                    pass
                else:
                    if 1 <= my < min(len(lines), maxy - 1):
                        selected = min(offset + my, len(lines) - 1)
            elif key in (curses.KEY_DOWN, ord("j")):
                if lines:
                    selected = min(selected + 1, len(lines) - 1)
            elif key in (curses.KEY_UP, ord("k")):
                if lines:
                    selected = max(1, selected - 1)
            elif key == curses.KEY_NPAGE:
                if lines:
                    page = maxy - 2
                    selected = min(len(lines) - 1, selected + page)
            elif key == curses.KEY_PPAGE:
                if lines:
                    page = maxy - 2
                    selected = max(1, selected - page)
            elif key in (ord("l"), ord("o"), ord("e")):
                if 0 < selected <= len(job_rows):
                    job = job_rows[selected - 1]
                    state = job.get("state")
                    if state in ("C", "F"):
                        try:
                            stdout_path, stderr_path = mqsub.PbsJobInfo.stdout_and_stderr_paths(job["id"])
                        except Exception:
                            stdout_path = stderr_path = None
                        if key == ord("e"):
                            path = stderr_path
                            suffix = "ER"
                        else:
                            path = stdout_path
                            suffix = "OU"
                        if path and os.path.isdir(path):
                            path = os.path.join(path, f"{job['id']}.{suffix}")
                        if path and os.path.exists(path):
                            curses.endwin()
                            subprocess.call(["less", path])
                            stdscr.clear()
                            curses.curs_set(0)
                    elif state == "R":
                        suffix = "ER" if key == ord("e") else "OU"
                        cmd = (
                            f"/pkg/hpc/scripts/ssh-to-job {job['id']} cat /var/spool/PBS/spool/{job['id']}.{suffix} | less"
                        )
                        curses.endwin()
                        subprocess.call(cmd, shell=True)
                        stdscr.clear()
                        curses.curs_set(0)
            elif key == ord("f"):
                if 0 < selected <= len(job_rows):
                    job = job_rows[selected - 1]
                    cmd = f"qstat -xf {job['id']} | less"
                    curses.endwin()
                    subprocess.call(cmd, shell=True)
                    stdscr.clear()
                    curses.curs_set(0)
            elif key == ord("s"):
                if 0 < selected <= len(job_rows):
                    job = job_rows[selected - 1]
                    if job.get("state") == "R":
                        curses.endwin()
                        subprocess.call(["/pkg/hpc/scripts/ssh-to-job", str(job["id"])])
                        stdscr.clear()
                        curses.curs_set(0)
                    else:
                        user_warning = "Job is not running"
                        user_warn_until = time.time() + 2
                else:
                    user_warning = "No job selected"
                    user_warn_until = time.time() + 2
            elif key == ord("g"):
                if 0 < selected <= len(job_rows):
                    job = job_rows[selected - 1]
                    url = grafana_url(job.get("id"))
                    curses.endwin()
                    print(url)
                    input("Press Enter to return...")
                    stdscr.clear()
                    curses.curs_set(0)
            elif key == ord("/"):
                curses.echo()
                stdscr.nodelay(False)
                stdscr.move(maxy - 1, 0)
                stdscr.clrtoeol()
                stdscr.addstr(maxy - 1, 0, "/")
                try:
                    query = stdscr.getstr(maxy - 1, 1).decode()
                except Exception:
                    query = ""
                stdscr.nodelay(True)
                curses.noecho()
                if query:
                    ql = query.lower()
                    for idx, job in enumerate(job_rows, start=1):
                        if ql in job.get("name", "").lower() or ql in str(job.get("id", "")).lower():
                            selected = idx
                            break
            elif key == ord("r"):
                refresh = True
            elif key == ord("u"):
                show_queued = not show_queued
                refresh = True
            elif key not in (-1, curses.KEY_MOUSE, curses.KEY_RESIZE):
                if 32 <= key <= 126:
                    user_warning = f"Unknown key '{chr(key)}'"
                else:
                    user_warning = "Unknown key"
                user_warn_until = time.time() + 2

            if refresh:
                jobs = get_jobs(include_history=True)
                now = time.time()
                running = []
                queued = []
                for job in jobs:
                    if job.get("queue") == "cpu_inter_exec":
                        continue
                    state = job.get("state")
                    if state in ("C", "F"):
                        finished[job["id"]] = job
                    elif state == "Q":
                        queued.append(job)
                    else:
                        running.append(job)
                if running or queued:
                    for jid, job in list(finished.items()):
                        ft = job.get("obittime") or job.get("mtime", now)
                        if now - ft > 24 * 3600:
                            finished.pop(jid, None)
                for jid, job in list(finished.items()):
                    if job.get("queue") == "cpu_inter_exec":
                        finished.pop(jid, None)

                running.sort(key=lambda j: j.get("walltime_used", 0), reverse=True)
                queued.sort(key=lambda j: now - j.get("qtime", now), reverse=True)
                finished_jobs = sorted(
                    finished.values(), key=lambda j: j.get("obittime") or j.get("mtime", 0), reverse=True
                )
                all_jobs = running + (queued if show_queued else []) + finished_jobs
                lines, job_rows = format_jobs(all_jobs, now=now)
                last_refresh = time.time()
                refresh = False

            stdscr.erase()
            warning = None
            if mqstat.parse_qstat.limit_hit:
                warning = "\x1b[91mWARNING: job list truncated; increase --max-jobs to see more running/queued jobs\x1b[0m"
            page = maxy - 3
            if lines:
                max_sel = len(lines) - 1
                selected = min(max(1, selected), max_sel)
                vis_rows = page - (1 if warning else 0)
                offset = max(0, min(offset, max_sel - vis_rows))
                if selected < offset + 1:
                    offset = selected - 1
                elif selected > offset + vis_rows:
                    offset = selected - vis_rows
                y = 0
                if warning:
                    draw_line(stdscr, 0, warning, maxx)
                    y = 1
                draw_line(stdscr, y, lines[0], maxx, highlight=True)
                visible = lines[1 + offset : 1 + offset + vis_rows]
                for i, line in enumerate(visible, start=y + 1):
                    draw_line(stdscr, i, line, maxx, highlight=(offset + i - y == selected))
            else:
                offset = 0
                selected = 1
            if user_warning:
                addstr_safe(stdscr, maxy - 2, 0, user_warning, maxx, curses.color_pair(2))
            help_text = (
                "q quit  / search  o stdout  e stderr  f full  s ssh  r refresh  u toggle queued  g grafana"
            )
            addstr_safe(stdscr, maxy - 1, 0, help_text, maxx, curses.A_REVERSE)
            stdscr.refresh()
            time.sleep(0.1)

    curses.wrapper(_draw)


if __name__ == "__main__":
    main()

