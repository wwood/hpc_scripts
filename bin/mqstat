#!/usr/bin/env python3
"""
Cluster Usage Monitor

This script analyzes PBS node information and job statistics to provide a summary of:
1. Overall cluster resource usage with ASCII art visualization
2. Nodes running at high CPU/RAM/GPU utilization (>80%)
3. Current user's resource consumption
4. Resource usage by all users in the "microbiome" group
"""

import subprocess
import re
import os
import pwd
import sys
import grp
import argparse
from collections import defaultdict
from datetime import datetime

# ANSI color codes
class Colors:
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

def run_command(command):
    """Execute a shell command and return the output."""
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = process.communicate()
    if process.returncode != 0:
        print(f"Error executing command: {command}")
        print(stderr.decode('utf-8'))
        return None
    return stdout.decode('utf-8')

def parse_pbsnodes_output():
    """Parse the output of `pbsnodes -a` into structured resource usage data."""
    output = run_command("pbsnodes -a")
    if not output:
        raise Exception("Failed to run pbsnodes -a")
    nodes = []
    current_node = {}
    node_name = None

    for line in output.splitlines():
        if not line.strip():  # empty line signifies possible end of a node block
            if current_node and node_name:
                nodes.append(current_node)
                current_node = {}
                node_name = None
            continue

        if not line.startswith(" "):  # new node
            if current_node and node_name:
                nodes.append(current_node)
                current_node = {}
            node_name = line.strip()
            current_node["name"] = node_name
            current_node["used_cpu"] = 0
            current_node["total_cpu"] = 0
            current_node["used_mem"] = 0
            current_node["total_mem"] = 0
            current_node["used_gpu"] = 0
            current_node["total_gpu"] = 0
            current_node["state"] = "unknown"
            continue

        line = line.strip()
        if line.startswith("resources_available.ncpus"):
            current_node["total_cpu"] = int(line.split("=")[-1].strip())
        elif line.startswith("resources_assigned.ncpus"):
            current_node["used_cpu"] = int(line.split("=")[-1].strip())
        elif line.startswith("resources_available.mem"):
            kb = int(line.split("=")[-1].strip().replace("kb", ""))
            current_node["total_mem"] = kb // (1024 * 1024)  # convert to GB
        elif line.startswith("resources_assigned.mem"):
            kb = int(line.split("=")[-1].strip().replace("kb", ""))
            current_node["used_mem"] = kb // (1024 * 1024)  # convert to GB
        elif line.startswith("resources_available.ngpus"):
            current_node["total_gpu"] = int(line.split("=")[-1].strip())
        elif line.startswith("resources_assigned.ngpus"):
            current_node["used_gpu"] = int(line.split("=")[-1].strip())
        elif line.startswith("state"):
            current_node["state"] = line.split("=")[-1].strip()

    # Append last node if needed
    if current_node and node_name:
        nodes.append(current_node)

    # Post-processing for percentages
    for node in nodes:
        total_cpu = node["total_cpu"]
        total_mem = node["total_mem"]
        total_gpu = node["total_gpu"]
        used_cpu = node["used_cpu"]
        used_mem = node["used_mem"]
        used_gpu = node["used_gpu"]

        node["cpu_usage"] = (used_cpu / total_cpu * 100) if total_cpu else 0
        node["ram_usage"] = (used_mem / total_mem * 100) if total_mem else 0
        node["gpu_usage"] = (used_gpu / total_gpu * 100) if total_gpu else 0

        # Derive state
        node["state"] = "free" if used_cpu == 0 else "job-busy"

    return nodes

def parse_qstat(path=None, include_history=False):
    """Parse qstat output to get job information."""
    if path is None:
        path = os.environ.get("MQSTAT_QSTAT_F")
    if path:
        with open(path) as f:
            output = f.read()
    else:
        # Full format for detailed information
        # Add -t to expand job arrays into individual jobs
        cmd = "qstat -f -t"
        if include_history:
            cmd = "qstat -xf -t"
        output = run_command(cmd)
        if not output:
            return []

    jobs = []
    current_job = None

    for line in output.splitlines():
        # Match job ID line
        job_match = re.match(r'^Job Id: (.+)$', line)
        if job_match:
            if current_job:
                jobs.append(current_job)
            current_job = {'id': job_match.group(1), 'user': None, 'ncpus': 0,
                           'cpu_usage': 0, 'mem_usage': 0, 'gpu_usage': 0,
                           'state': None}
            continue

        if not current_job:
            continue

        # Match job name
        name_match = re.search(r'Job_Name = (.+)', line)
        if name_match:
            current_job['name'] = name_match.group(1)

        # Match queue
        queue_match = re.search(r'queue = (.+)', line)
        if queue_match:
            current_job['queue'] = queue_match.group(1)

        # Match job owner
        owner_match = re.search(r'Job_Owner = (.+)@', line)
        if owner_match:
            current_job['user'] = owner_match.group(1)

        # Match job state
        state_match = re.search(r'job_state = ([A-Z])', line)
        if state_match:
            current_job['state'] = state_match.group(1)

        # Finished time
        mtime_match = re.search(r'mtime = (.+)', line)
        if mtime_match:
            try:
                dt = datetime.strptime(mtime_match.group(1).strip(), "%a %b %d %H:%M:%S %Y")
                current_job['mtime'] = int(dt.timestamp())
            except ValueError:
                pass

        # Match resource usage and requests
        if 'resources_used' in line or 'Resource_List' in line:
            # ncpus requested
            cpu_match = re.search(r'Resource_List.ncpus = (\d+)', line)
            if cpu_match:
                current_job['ncpus'] = int(cpu_match.group(1))

            # CPU percentage
            cpu_match = re.search(r'resources_used.cpupercent = (\d+)', line)
            if cpu_match:
                current_job['cpupercent'] = int(cpu_match.group(1))

            ncpus_used_match = re.search(r'resources_used.ncpus = (\d+)', line)
            if ncpus_used_match:
                current_job['ncpus_used'] = int(ncpus_used_match.group(1))

            # Memory usage
            if 'resources_used.mem' in line:
                mem_match1 = re.search(r'resources_used.mem = (\d+)kb', line)
                mem_match2 = re.search(r'resources_used.mem = (\d+)gb', line)
                mem_match3 = re.search(r'resources_used.mem = 0b', line)
                if mem_match1:
                    current_job['mem_usage'] = int(mem_match1.group(1))
                elif mem_match2:
                    current_job['mem_usage'] = int(mem_match2.group(1)) * 1024 * 1024
                elif mem_match3:
                    current_job['mem_usage'] = 0
                else:
                    raise Exception("Unknown memory unit from line: " + line)

            # Memory requested
            mem_req_match = re.search(r'Resource_List.mem = (\d+)([a-zA-Z]+)', line)
            if mem_req_match:
                val = int(mem_req_match.group(1))
                unit = mem_req_match.group(2).lower()
                if unit == 'gb':
                    mem_gb = val
                elif unit == 'mb':
                    mem_gb = val / 1024
                elif unit == 'kb':
                    mem_gb = val / (1024 * 1024)
                else:
                    mem_gb = 0
                current_job['mem_request_gb'] = mem_gb

            # GPU
            gpu_match = re.search(r'Resource_List.ngpus = (\d+)', line)
            if gpu_match:
                current_job['ngpus'] = int(gpu_match.group(1))

            # walltime used
            walltime_match = re.search(r'resources_used.walltime = (\d+):(\d+):(\d+)', line)
            if walltime_match:
                h, m, s = map(int, walltime_match.groups())
                current_job['walltime_used'] = h * 3600 + m * 60 + s
                if 'walltime_total' in current_job:
                    current_job['walltime'] = current_job['walltime_total'] - current_job['walltime_used']

            # CPU time used
            cput_match = re.search(r'resources_used.cput = (\d+):(\d+):(\d+)', line)
            if cput_match:
                h, m, s = map(int, cput_match.groups())
                current_job['cput_used'] = h * 3600 + m * 60 + s

            # vmem used
            vmem_match = re.search(r'resources_used.vmem = (\d+)([a-zA-Z]+)', line)
            if vmem_match:
                val = int(vmem_match.group(1))
                unit = vmem_match.group(2).lower()
                if unit == 'kb':
                    vmem_kb = val
                elif unit == 'mb':
                    vmem_kb = val * 1024
                elif unit == 'gb':
                    vmem_kb = val * 1024 * 1024
                else:
                    vmem_kb = 0
                current_job['vmem_used_kb'] = vmem_kb

            # Requested walltime
            walltime_match = re.search(r'Resource_List.walltime = (\d+):(\d+):(\d+)', line)
            if walltime_match:
                h, m, s = map(int, walltime_match.groups())
                requested_walltime = h * 3600 + m * 60 + s
                current_job['walltime_total'] = requested_walltime
                # Deduct the time already used, if already running
                if 'walltime_used' in current_job:
                    current_job['walltime'] = requested_walltime - current_job['walltime_used']
                else:
                    current_job['walltime'] = requested_walltime
                # The true cpu time ncpus * walltime
                current_job['cpu_usage_remaining'] = current_job['ncpus'] * current_job['walltime']
                # gpus
                if 'ngpus' in current_job:
                    current_job['gpu_usage_remaining'] = current_job['ngpus'] * current_job['walltime']
        exit_match = re.search(r'exit_status = (\d+)', line)
        if exit_match:
            current_job['exit_status'] = int(exit_match.group(1))

    # Add the last job
    if current_job:
        jobs.append(current_job)

    return jobs

def get_job_status_counts(jobs):
    """Count jobs by status (running, queued, held)."""
    status_counts = defaultdict(int)
    
    for job in jobs:
        state = job.get('state')
        if state == 'R':
            status_counts['running'] += 1
        elif state == 'Q':
            status_counts['queued'] += 1
        elif state == 'H':
            status_counts['held'] += 1
        else:
            status_counts['other'] += 1
    
    total = sum(status_counts.values())
    running_percent = (status_counts['running'] / total * 100) if total > 0 else 0
    
    return {
        'running': status_counts['running'],
        'queued': status_counts['queued'],
        'held': status_counts['held'],
        'other': status_counts['other'],
        'total': total,
        'running_percent': running_percent
    }

def get_real_name(username):
    """Get the real name for a username."""
    try:
        pwd_entry = pwd.getpwnam(username)
        gecos = pwd_entry.pw_gecos
        real_name = gecos.split(',')[0] if gecos else username
        return real_name if real_name else username
    except KeyError:
        return username

def calculate_cluster_stats(nodes):
    """Calculate summary statistics about cluster usage."""
    total_nodes = len(nodes)
    active_nodes = sum(1 for node in nodes if node['used_cpu'] > 0)
    
    high_cpu_nodes = sum(1 for node in nodes if node['cpu_usage'] >= 80)
    high_ram_nodes = sum(1 for node in nodes if node['ram_usage'] >= 80)
    high_gpu_nodes = sum(1 for node in nodes if node['gpu_usage'] >= 80 and node['total_gpu'] > 0)
    
    total_cpu_cores = sum(node['total_cpu'] for node in nodes)
    used_cpu_cores = sum(node['used_cpu'] for node in nodes)
    
    total_memory_gb = sum(node['total_mem'] for node in nodes)
    used_memory_gb = sum(node['used_mem'] for node in nodes)
    
    total_cpu_only_cores = sum(node['total_cpu'] for node in nodes if node['total_gpu'] == 0)
    used_cpu_only_cores = sum(node['used_cpu'] for node in nodes if node['total_gpu'] == 0)

    total_gpus = sum(node['total_gpu'] for node in nodes)
    used_gpus = sum(node['used_gpu'] for node in nodes)
    
    avg_cpu = sum(node['cpu_usage'] for node in nodes) / total_nodes if total_nodes else 0
    avg_ram = sum(node['ram_usage'] for node in nodes) / total_nodes if total_nodes else 0
    
    # Only include nodes with GPUs in the GPU averages
    gpu_nodes = sum(1 for node in nodes if node['total_gpu'] > 0)
    avg_gpu = sum(node['gpu_usage'] for node in nodes if node['total_gpu'] > 0) / gpu_nodes if gpu_nodes else 0
    
    return {
        'total_nodes': total_nodes,
        'active_nodes': active_nodes,
        'high_cpu_nodes': high_cpu_nodes,
        'high_cpu_percentage': (high_cpu_nodes / total_nodes * 100) if total_nodes else 0,
        'high_ram_nodes': high_ram_nodes,
        'high_ram_percentage': (high_ram_nodes / total_nodes * 100) if total_nodes else 0,
        'high_gpu_nodes': high_gpu_nodes,
        'high_gpu_percentage': (high_gpu_nodes / gpu_nodes * 100) if gpu_nodes else 0,
        'avg_cpu': avg_cpu,
        'avg_ram': avg_ram,
        'avg_gpu': avg_gpu,
        'total_cpu_cores': total_cpu_cores,
        'used_cpu_cores': used_cpu_cores,
        'cpu_utilization': (used_cpu_cores / total_cpu_cores * 100) if total_cpu_cores else 0,
        'total_memory_gb': total_memory_gb,
        'used_memory_gb': used_memory_gb,
        'memory_utilization': (used_memory_gb / total_memory_gb * 100) if total_memory_gb else 0,
        'total_cpu_only_cores': total_cpu_only_cores,
        'used_cpu_only_cores': used_cpu_only_cores,
        'cpu_only_utilization': (used_cpu_only_cores / total_cpu_only_cores * 100) if total_cpu_only_cores else 0,
        'total_gpus': total_gpus,
        'used_gpus': used_gpus,
        'gpu_utilization': (used_gpus / total_gpus * 100) if total_gpus else 0
    }

def get_unix_group_members(group_name):
    """Get all users belonging to a Unix group."""
    try:
        group = grp.getgrnam(group_name)
        return group.gr_mem
    except KeyError:
        print(f"Group '{group_name}' not found")
        return []

def calculate_user_stats(jobs, ignore_interactive=False):
    """Calculate statistics for a specific user or group."""
    if ignore_interactive:
        user_jobs = [job for job in jobs if not job['queue'] in ('cpu_inter_exec','gpu_inter_exec')]
    else:
        user_jobs = jobs
    
    job_status = get_job_status_counts(user_jobs)
    total_jobs = len(user_jobs)
    total_cpu = sum(job['cpu_usage_remaining'] for job in user_jobs)
    total_mem = sum(job['mem_usage'] for job in user_jobs)
    total_gpu = sum(job['gpu_usage'] for job in user_jobs)
    running_cpu = sum(job['ncpus'] for job in user_jobs if job['state'] == 'R')
    running_gpu = sum(job['ngpus'] for job in user_jobs if job['state'] == 'R')
    total_ncpus = sum(job['ncpus'] for job in user_jobs)
    total_ngpus = sum(job['ngpus'] for job in user_jobs)
    total_walltime = sum(job['walltime'] for job in user_jobs)

    # already a %
    # Sometimes get R but no 'cpupercent' key, I guess they are just starting?
    running_cpu_util_total = sum(job['cpupercent'] for job in user_jobs if job['state'] == 'R' and 'cpupercent' in job)
    running_cpu_utilisation = running_cpu_util_total / running_cpu if len(user_jobs) > 0 and running_cpu > 0 else 0

    # speed is roughly running cpus/ Total is cpu_usage_remaining
    eta = total_cpu / running_cpu if running_cpu > 0 else 0
    
    return {
        'job_status': job_status,
        'total_jobs': total_jobs,
        'total_cpu_seconds': total_cpu,
        'total_cpu_hours': total_cpu / 3600,
        'total_memory_kb': total_mem,
        'total_memory_gb': total_mem / (1024 * 1024),
        'total_gpus': total_gpu,
        'avg_cpu_per_job': total_cpu / total_jobs if total_jobs else 0,
        'avg_mem_per_job': total_mem / total_jobs if total_jobs else 0,
        'avg_gpu_per_job': total_gpu / total_jobs if total_jobs else 0,
        'running_cpu': running_cpu,
        'running_gpu': running_gpu,
        'total_ncpus': total_ncpus,
        'total_ngpus': total_ngpus,
        'total_walltime': total_walltime,
        'eta': eta,
        'running_cpu_utilisation': running_cpu_utilisation,
    }

def format_hms(seconds):
    """Format seconds to HH:MM:SS."""
    if seconds is None:
        return ""
    h = seconds // 3600
    m = (seconds % 3600) // 60
    s = seconds % 60
    return f"{h:02}:{m:02}:{s:02}"


def format_hm(seconds):
    """Format seconds to HH:MM."""
    if seconds is None:
        return ""
    h = seconds // 3600
    m = (seconds % 3600) // 60
    return f"{h:02}:{m:02}"


def progress_bar(used, total, width=20):
    """Return a coloured progress bar representing used/total."""
    if not total:
        ratio = 0
    else:
        ratio = used / total
    filled = int(ratio * width)
    bar = "â–ˆ" * filled + "-" * (width - filled)
    colour = Colors.RED if ratio > 0.8 else Colors.GREEN
    return f"{colour}{bar}{Colors.ENDC}"

def format_time_hours(seconds, descriptor=""):
    """Format seconds into hours, days, months, years or millenia."""
    hours = seconds / 3600
    descriptor = f" {descriptor}" if descriptor else ""
    if hours >= 876000:  # 1 millenia = 876000 hours
        millenia = hours / 876000
        return f"{millenia:.1f}{descriptor} millenia"
    elif hours >= 8760:  # 1 year = 8760 hours
        years = hours / 8760
        return f"{years:.1f}{descriptor} years"
    elif hours >= 730:  # 1 month = 730 hours (approx)
        months = hours / 730
        return f"{months:.1f}{descriptor} months"
    elif hours >= 24:
        days = hours / 24
        return f"{days:.1f}{descriptor} days"
    else:
        return f"{hours:.1f}{descriptor} hours"

def create_ascii_bar(percentage, width=40, reverse=False, colour_text=None):
    """Create an ASCII progress bar with color based on percentage."""
    filled_width = int(percentage / 100 * width)
    empty_width = width - filled_width
    
    if reverse:
        if percentage < 40:
            color = Colors.RED
        elif percentage < 70:
            color = Colors.YELLOW
        else:
            color = Colors.GREEN
    else:
        if percentage < 50:
            color = Colors.GREEN
        elif percentage < 80:
            color = Colors.YELLOW
        else:
            color = Colors.RED

    bar = f"{color}{'â–ˆ' * filled_width}{Colors.ENDC}{'â–‘' * empty_width} {percentage:.1f}%"
    if colour_text:
        bar = coloured_text(colour_text, color) + bar
    
    return bar

def coloured_text(text, color):
    """Apply color to text."""
    return f"{color}{text}{Colors.ENDC}"

def parse_qusers_output():
    """
    Parse the qusers output and return a dictionary:
    {
        username: {
            'cpus_running': int,
            'cpus_queued': int,
            'gpus_running': int,
            'gpus_queued': int
        },
        ...
    }
    Only use the #run/#queue pairs under CPUs and GPUs, not the jobs section.
    """
    qusers_text = run_command("qusers")

    users = {}
    lines = qusers_text.splitlines()
    # Find the header line with #run and #queue
    for i, line in enumerate(lines):
        if '#run' in line and '#queue' in line:
            header_idx = i
            break
    else:
        return users  # header not found
    header = lines[header_idx]
    # Find all #run and #queue end indices
    def all_col_end_indices(header, colname):
        idxs = []
        pos = 0
        while True:
            pos = header.find(colname, pos)
            if pos == -1:
                break
            idxs.append(pos + len(colname) - 1)
            pos += len(colname)
        return idxs
    run_ends = all_col_end_indices(header, '#run')
    queue_ends = all_col_end_indices(header, '#queue')
    # Use the 2nd and 3rd pairs: CPUs and GPUs
    if len(run_ends) < 3 or len(queue_ends) < 3:
        return users  # not enough columns found
    cpu_run_end = run_ends[1]
    cpu_queue_end = queue_ends[1]
    gpu_run_end = run_ends[2]
    gpu_queue_end = queue_ends[2]
    # Data starts after the header and separator
    for line in lines[header_idx+2:]:
        if not line.strip() or line.startswith('=') or line.startswith('Totals'):
            continue
        username = line[:line.find('|')].strip()
        def extract_int_backwards(line, end_idx):
            if end_idx is None or end_idx >= len(line):
                return 0
            start = end_idx
            while start >= 0 and line[start] != ' ':
                start -= 1
            val = line[start+1:end_idx+1].strip()
            return int(val) if val.isdigit() else 0
        cpus_running = extract_int_backwards(line, cpu_run_end)
        cpus_queued = extract_int_backwards(line, cpu_queue_end)
        gpus_running = extract_int_backwards(line, gpu_run_end)
        gpus_queued = extract_int_backwards(line, gpu_queue_end)
        users[username] = {
            'cpus_running': cpus_running,
            'cpus_queued': cpus_queued,
            'gpus_running': gpus_running,
            'gpus_queued': gpus_queued
        }
    return users

def job_table(jobs, finished=False):
    """Return formatted job table lines."""
    rows = []
    for job in jobs:
        queue = job.get('queue', '')
        if queue in ('cpu_inter_exec', 'gpu_inter_exec'):
            continue
        queue = queue.replace('_batch_exec', '')
        job_id = job.get('id', '')
        name = job.get('name', '')
        used_s = job.get('walltime_used', 0)
        total_s = job.get('walltime_total', job.get('walltime', 0))
        used = format_hm(used_s)
        total = format_hm(total_s)
        bar = progress_bar(used_s, total_s)
        cpu = job.get('ncpus', 0)
        cpu_icon = 'ðŸ’ª' if cpu > 48 else ''
        ram = int(job.get('mem_request_gb', 0))
        ram_icon = 'ðŸ§ ' if ram > 187 else ''
        state = job.get('state', '')
        note = ''
        cpupercent = job.get('cpupercent')
        ncpus_used = job.get('ncpus_used', job.get('ncpus', 0))
        if cpupercent is not None and ncpus_used:
            if cpupercent < ncpus_used * 10:
                note = 'â— over-resourced? <10% of CPU used'
        if finished:
            cput_used = job.get('cput_used', 0)
            cpu_util = 0
            if used_s and cpu > 0:
                cpu_util = cput_used / (used_s * cpu) * 100
            cpu_util_str = f"{int(cpu_util)}%"
            cpu_low = cpu_util < 10

            vmem_kb = job.get('vmem_used_kb', 0)
            ram_util = 0
            if ram:
                ram_util = vmem_kb / (ram * 1024 * 1024) * 100
            ram_util_str = f"{int(ram_util)}%"
            ram_low = ram_util < 10

            if used_s < 60:
                note = 'short'
            elif cpu_low and ram_low:
                note = '<10% CPU, <10% RAM'
            elif cpu_low:
                note = '<10% CPU'
            elif ram_low:
                note = '<10% RAM'
            if job.get('exit_status', 0) != 0:
                note = '!' + note
            row = [
                job_id,
                name,
                used,
                bar,
                total,
                cpu,
                cpu_icon,
                cpu_util_str,
                cpu_low,
                ram,
                ram_icon,
                ram_util_str,
                ram_low,
                queue,
                note,
            ]
        else:
            row = [job_id, name, used, bar, total, cpu, cpu_icon, ram, ram_icon, state, queue, note]
        rows.append(row)

    if finished:
        headers = [
            "job_id",
            "name",
            "time used",
            "progress",
            "walltime",
            "CPU",
            "util (%)",
            "RAM(G)",
            "util (%)",
            "queue",
            "note",
        ]
    else:
        headers = ["job_id", "name", "time used", "progress", "walltime", "CPU", "RAM(G)", "state", "queue", "note"]
    if not rows:
        return ["  ".join(headers)]

    id_w = max(len(headers[0]), max(len(r[0]) for r in rows))
    name_w = max(len(headers[1]), max(len(r[1]) for r in rows))
    time_w = len(headers[2])
    wall_w = max(len(headers[4]), max(len(r[4]) for r in rows))
    icon_w = 2  # emoji take two columns

    if finished:
        cpu_w = max(len(headers[5]), max(len(str(r[5])) for r in rows))
        cpuu_w = max(len(headers[6]), max(len(r[7]) for r in rows))
        ram_w = max(len(headers[7]), max(len(str(r[9])) for r in rows))
        ramu_w = max(len(headers[8]), max(len(r[11]) for r in rows))
        queue_w = max(len(headers[9]), max(len(r[13]) for r in rows))
        note_w = max(len(headers[10]), max(len(r[14]) for r in rows))

        def colour(val, low):
            return f"{Colors.RED}{val}{Colors.ENDC}" if low else val

        header_parts = [
            headers[0].ljust(id_w),
            headers[1].ljust(name_w),
            headers[2].ljust(time_w),
            headers[3].ljust(20),
            headers[4].ljust(wall_w),
            headers[5].rjust(cpu_w) + ' ' * icon_w,
            headers[6].rjust(cpuu_w),
            headers[7].rjust(ram_w) + ' ' * icon_w,
            headers[8].rjust(ramu_w),
            headers[9].ljust(queue_w),
            headers[10].ljust(note_w),
        ]
        lines = ["  ".join(header_parts)]
        for r in rows:
            parts = [
                r[0].ljust(id_w),
                r[1].ljust(name_w),
                r[2].ljust(time_w),
                r[3],
                r[4].ljust(wall_w),
                str(r[5]).rjust(cpu_w) + r[6] + ' ' * (icon_w - (2 if r[6] else 0)),
                colour(r[7], r[8]).rjust(cpuu_w),
                str(r[9]).rjust(ram_w) + r[10] + ' ' * (icon_w - (2 if r[10] else 0)),
                colour(r[11], r[12]).rjust(ramu_w),
                r[13].ljust(queue_w),
                r[14].ljust(note_w),
            ]
            lines.append("  ".join(parts))
        return lines
    else:
        cpu_w = max(len(headers[5]), max(len(str(r[5])) for r in rows))
        ram_w = max(len(headers[6]), max(len(str(r[7])) for r in rows))
        state_w = max(len(headers[7]), max(len(r[9]) for r in rows))
        queue_w = max(len(headers[8]), max(len(r[10]) for r in rows))
        note_w = max(len(headers[9]), max(len(r[11]) for r in rows))

        header_parts = [
            headers[0].ljust(id_w),
            headers[1].ljust(name_w),
            headers[2].ljust(time_w),
            headers[3].ljust(20),
            headers[4].ljust(wall_w),
            headers[5].rjust(cpu_w) + ' ' * icon_w,
            headers[6].rjust(ram_w) + ' ' * icon_w,
            headers[7].ljust(state_w),
            headers[8].ljust(queue_w),
            headers[9].ljust(note_w),
        ]
        lines = ["  ".join(header_parts)]
        for r in rows:
            parts = [
                r[0].ljust(id_w),
                r[1].ljust(name_w),
                r[2].ljust(time_w),
                r[3],
                r[4].ljust(wall_w),
                str(r[5]).rjust(cpu_w) + r[6] + ' ' * (icon_w - (2 if r[6] else 0)),
                str(r[7]).rjust(ram_w) + r[8] + ' ' * (icon_w - (2 if r[8] else 0)),
                r[9].ljust(state_w),
                r[10].ljust(queue_w),
                r[11].ljust(note_w),
            ]
            lines.append("  ".join(parts))
        return lines


def list_jobs(jobs):
    """Print job table."""
    for line in job_table(jobs):
        print(line)


def watch_jobs(get_jobs, interval=2):
    """Continuously display job list, updating every interval seconds."""
    import curses
    import time
    import re
    import unicodedata

    finished = {}

    ansi_re = re.compile(r"\x1b\[(\d+)m(.*?)\x1b\[0m")

    def _width(ch):
        if unicodedata.combining(ch):
            return 0
        return 2 if unicodedata.east_asian_width(ch) in ("F", "W") else 1

    def addstr_safe(stdscr, y, x, text, maxx, colour=0):
        width = 0
        out = []
        for ch in text:
            w = _width(ch)
            if x + width + w > maxx - 1:
                break
            out.append(ch)
            width += w
        if out:
            try:
                stdscr.addstr(y, x, "".join(out), colour)
            except curses.error:
                pass
        return width

    def draw_line(stdscr, y, line, maxx):
        """Draw a line that may contain multiple ANSI colour escape codes."""
        x = 0
        last = 0
        for match in ansi_re.finditer(line):
            x += addstr_safe(stdscr, y, x, line[last:match.start()], maxx)
            colour = match.group(1)
            colour_pair = curses.color_pair(1 if colour == '92' else 2)
            x += addstr_safe(stdscr, y, x, match.group(2), maxx, colour_pair)
            last = match.end()
            if x >= maxx - 1:
                break
        if x < maxx - 1 and last < len(line):
            addstr_safe(stdscr, y, x, line[last:], maxx)

    def _draw(stdscr):
        curses.curs_set(0)
        curses.start_color()
        curses.use_default_colors()
        curses.init_pair(1, curses.COLOR_GREEN, -1)
        curses.init_pair(2, curses.COLOR_RED, -1)
        stdscr.nodelay(True)
        while True:
            key = stdscr.getch()
            if key == ord('q'):
                break
            jobs = get_jobs(include_history=True)
            running = []
            now = time.time()
            for job in jobs:
                if job.get('state') in ('C', 'F'):
                    mtime = job.get('mtime', now)
                    if now - mtime <= 24 * 3600:
                        finished[job['id']] = job
                else:
                    running.append(job)
            # remove finished jobs older than 24h
            for jid, job in list(finished.items()):
                if now - job.get('mtime', now) > 24 * 3600:
                    finished.pop(jid, None)
            stdscr.erase()
            maxy, maxx = stdscr.getmaxyx()
            half = maxy // 2
            lines_running = job_table(running)
            lines_finished = job_table(list(finished.values()), finished=True)
            for i, line in enumerate(lines_running[:half]):
                draw_line(stdscr, i, line, maxx)
            title_y = half
            stdscr.addstr(title_y, 0, "Finished jobs ===="[:maxx-1])
            for i, line in enumerate(lines_finished[:maxy - half - 1]):
                draw_line(stdscr, title_y + 1 + i, line, maxx)
            stdscr.refresh()
            time.sleep(interval)

    curses.wrapper(_draw)

def main():
    parser = argparse.ArgumentParser(description="Cluster Usage Monitor")
    parser.add_argument("--list", action="store_true", help="Summarise qstat -f output")
    parser.add_argument("--watch", action="store_true", help="Continuously watch job list")
    parser.add_argument("--qstat-file", help="Use qstat -f output from file")
    args = parser.parse_args()

    if args.list:
        jobs = parse_qstat(path=args.qstat_file)
        list_jobs(jobs)
        return
    if args.watch:
        def get_jobs(include_history=False):
            return parse_qstat(path=args.qstat_file, include_history=include_history)
        watch_jobs(get_jobs)
        return

    # Get node data
    nodes = parse_pbsnodes_output()

    if not nodes:
        print("Failed to gather node information. Check if pbsnodeinfo is available.")
        return

    # Get qusers data
    qusers_stats = parse_qusers_output()

    # Calculate cluster stats
    cluster_stats = calculate_cluster_stats(nodes)

    # Get job data
    jobs = parse_qstat(path=args.qstat_file)
    
    # Get microbiome group members
    microbiome_members = get_unix_group_members("microbiome")
    # skip admins
    microbiome_members = [member for member in microbiome_members if member not in [
        'thomsonv',
    ]]
    
    # Calculate user stats
    user_stats = calculate_user_stats(jobs, ignore_interactive=True)
    
    print("\n=== YOU ===")
    if user_stats and user_stats['total_jobs'] > 0:
        job_status = user_stats['job_status']
        # ETA
        print(f"ETA: {format_time_hours(user_stats['eta'])}")
        print(f"Walltime remaining: {format_time_hours(user_stats['total_walltime'])}")
        print(f"CPU hours remaining: {format_time_hours(user_stats['total_cpu_seconds'])}")
        print()
        print(f"Jobs: {job_status['running']} of {job_status['total']} running")
        # print(f"Run:   {create_ascii_bar(job_status['running_percent'], reverse=True)}")
        print(f"{create_ascii_bar(job_status['running_percent'], reverse=True, colour_text='Run:   ')}")
        print(f"{create_ascii_bar(user_stats['running_cpu_utilisation'], reverse=True, colour_text='Util:  ')}")

        if job_status['held'] > 0:
            print(f"Jobs held: {job_status['held']} !!")

        # print(f"Jobs: {job_status['total']} total ({job_status['running']} running, {job_status['queued']} queued, {job_status['held']} held, {job_status['running_percent']:.1f}% running)")
        # print(f"CPU:   {create_ascii_bar(user_stats['running_cpu'] / user_stats['total_ncpus'] * 100)}")
        # if user_stats['total_gpus'] > 0:
        #     print(f"GPU:   {create_ascii_bar(user_stats['running_gpu'] / cluster_stats['total_gpus'] * 100)}")
        # print(f"Total memory usage: {user_stats['total_memory_gb']:.2f} GB")
        # if user_stats['total_gpus'] > 0:
        #     print(f"Total GPU usage: {user_stats['total_gpus']} GPUs")
    else:
        print(f"No batch jobs found.")
    
    print("\n\n=== CMR ===")
    # Calculate overall stats
    microbiome_used_cpu = 0
    microbiome_used_gpu = 0
    microbiome_requested_cpu = 0
    for member, stats in qusers_stats.items():
        if member in microbiome_members:
            microbiome_used_cpu += stats['cpus_running']
            microbiome_used_gpu += stats['gpus_running']
            microbiome_requested_cpu += stats['cpus_running'] + stats['cpus_queued']

    microbiome_cpu_percent = microbiome_used_cpu / cluster_stats['total_cpu_cores'] * 100
    microbiome_gpu_percent = microbiome_used_gpu / cluster_stats['total_gpus'] * 100
    microbiome_cpu_requested_percent = microbiome_used_cpu / microbiome_requested_cpu * 100

    print(f"CPU:   {create_ascii_bar(microbiome_cpu_percent)}")
    if cluster_stats['total_gpus'] > 0 and microbiome_used_gpu > 0:
        print(f"GPU:   {create_ascii_bar(microbiome_gpu_percent)}")

    print(f"Requested CPUs: {microbiome_requested_cpu:,} ({microbiome_cpu_requested_percent:.1f}% running)")
    print()

    # Calculate score for each member: cpus_running + 10 * gpus_running
    scored_members = []
    for member in microbiome_members:
        if member in qusers_stats:
            stats = qusers_stats[member]
            score = stats['cpus_running'] + 10 * stats['gpus_running']
            real_name = get_real_name(member)
            scored_members.append((real_name, stats, score))
    # Sort by score descending and print top 5
    sorted_members = sorted(scored_members, key=lambda x: x[2], reverse=True)[:5]
    
    if scored_members:
        # Print table header
        print(f"{'#':<3} {'Member':<20} {'CPU':>12} {'GPU':>10} {'Score':>6}")
        print(f"{'-'*3:<3} {'-'*20:<20} {'-'*12:>12} {'-'*10:>10} {'-'*6:>6}")
        
        # Print each member with proper alignment
        for i, (member, stats, score) in enumerate(sorted_members, 1):
            cpu_display = f"{stats['cpus_running']:,}/{stats['cpus_running'] + stats['cpus_queued']:,}"
            # Show empty space if no GPUs requested
            total_gpus_requested = stats['gpus_running'] + stats['gpus_queued']
            gpu_display = f"{stats['gpus_running']}/{total_gpus_requested}" if total_gpus_requested > 0 else ""
            print(f"{i:<3} {member:<20} {cpu_display:>12} {gpu_display:>10} {score:>6}")
    else:
        print("No jobs for microbiome group members.")
    
    # Print the report
    print("\n\n=== CLUSTER ===")
    
    # ASCII art utilization bars
    print(f"CPU-all:  {create_ascii_bar(cluster_stats['cpu_utilization'])}")
    print(f"RAM-all:  {create_ascii_bar(cluster_stats['memory_utilization'])}")
    if cluster_stats['total_gpus'] > 0:
        print(f"CPU-only: {create_ascii_bar(cluster_stats['cpu_only_utilization'])}")
        print(f"GPU:      {create_ascii_bar(cluster_stats['gpu_utilization'])}")
    print(f'Nodes:    {create_ascii_bar(cluster_stats["active_nodes"]/cluster_stats["total_nodes"]*100)}')
    
    # Num cpus, total ram, gpus
    ram_tb = cluster_stats['total_memory_gb'] / 1024
    print(f"\nTotal {cluster_stats['total_cpu_cores']:,} CPUs, {ram_tb:.1f} TB RAM, {cluster_stats['total_gpus']} GPUs")

    print()

if __name__ == "__main__":
    main()
