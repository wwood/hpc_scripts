#!/usr/bin/env python3
"""Interactive job viewer similar to ``htop``.

This tool combines running and recently finished jobs into a single table
and allows selecting rows to inspect job logs.
"""

import argparse
import importlib.util
import os
import re
import subprocess
import time
import unicodedata
from importlib.machinery import SourceFileLoader

import curses


def _load_script(name):
    """Load a script from ``bin`` as a module."""

    path = os.path.join(os.path.dirname(__file__), name)
    loader = SourceFileLoader(f"{name}_module", path)
    spec = importlib.util.spec_from_loader(f"{name}_module", loader)
    mod = importlib.util.module_from_spec(spec)
    loader.exec_module(mod)
    return mod


mqstat = _load_script("mqstat")
mqsub = _load_script("mqsub")


ansi_re = re.compile(r"\x1b\[(\d+)m(.*?)\x1b\[0m")
# basic ANSI colour escapes used for row colouring
ORANGE = "\033[33m"


def strip_ansi(text: str) -> str:
    """Return *text* with ANSI colour escapes removed."""

    return ansi_re.sub(r"\2", text)


def visible_len(text: str) -> int:
    """Length of *text* ignoring ANSI colour escapes."""

    return len(strip_ansi(text))


def ljust_ansi(text: str, width: int) -> str:
    pad = max(width - visible_len(text), 0)
    return text + " " * pad


def rjust_ansi(text: str, width: int) -> str:
    pad = max(width - visible_len(text), 0)
    return " " * pad + text


def _width(ch):
    if unicodedata.combining(ch):
        return 0
    return 2 if unicodedata.east_asian_width(ch) in ("F", "W") else 1


def addstr_safe(stdscr, y, x, text, maxx, attr=0):
    width = 0
    out = []
    for ch in text:
        w = _width(ch)
        if x + width + w > maxx - 1:
            break
        out.append(ch)
        width += w
    if out:
        try:
            stdscr.addstr(y, x, "".join(out), attr)
        except curses.error:
            pass
    return width


def draw_line(stdscr, y, line, maxx, highlight=False):
    """Draw a line that may contain ANSI colour escape codes."""

    x = 0
    last = 0
    attr = curses.A_REVERSE if highlight else 0
    for match in ansi_re.finditer(line):
        x += addstr_safe(stdscr, y, x, line[last:match.start()], maxx, attr)
        colour = match.group(1)
        pair = {"92": 1, "91": 2, "93": 3, "33": 4}.get(colour, 0)
        colour_pair = curses.color_pair(pair)
        x += addstr_safe(stdscr, y, x, match.group(2), maxx, colour_pair | attr)
        last = match.end()
        if x >= maxx - 1:
            break
    if x < maxx - 1 and last < len(line):
        addstr_safe(stdscr, y, x, line[last:], maxx, attr)


def format_jobs(jobs, now=None):
    """Return formatted job table lines and corresponding job objects."""

    if now is None:
        now = time.time()

    rows = []
    headers = [
        "job_id",
        "name",
        "time used",
        "progress",
        "walltime",
        "waited",
        "CPU",
        "cpu%",
        "RAM(G)",
        "ram%",
        "state",
        "queue",
        "note",
    ]

    for job in jobs:
        if job.get("queue") == "cpu_inter_exec":
            continue
        queue = job.get("queue", "").replace("_batch_exec", "")
        job_id = job.get("id", "")
        name = job.get("name", "")
        used_s = job.get("walltime_used", 0)
        total_s = job.get("walltime_total", job.get("walltime", 0))
        used = mqstat.format_hm(used_s)
        total = mqstat.format_hm(total_s)
        bar = mqstat.progress_bar(used_s, total_s)
        waited = ""
        qtime = job.get("qtime")
        start_time = job.get("start_time")
        if qtime and start_time and start_time > qtime:
            waited = mqstat.format_hm(start_time - qtime)

        cpu = job.get("ncpus", 0)
        cpupercent = job.get("cpupercent")
        ncpus_used = job.get("ncpus_used", cpu)
        cpu_util = 0
        if job.get("state") in ("C", "F"):
            cput_used = job.get("cput_used", 0)
            if used_s and cpu:
                cpu_util = cput_used / (used_s * cpu) * 100
        elif cpupercent is not None and ncpus_used:
            cpu_util = cpupercent / ncpus_used
        cpu_util_str = f"{int(cpu_util)}%" if cpu_util else ""
        cpu_low = cpu_util and cpu_util < 10
        short_run = used_s <= 120

        ram = int(job.get("mem_request_gb", 0))
        vmem_kb = job.get("vmem_used_kb") or job.get("mem_usage", 0)
        ram_util = (vmem_kb / (ram * 1024 * 1024) * 100) if ram else 0
        ram_util_str = f"{int(ram_util)}%" if ram_util else ""
        ram_low = ram_util and ram_util < 10

        state = job.get("state", "")
        note = ""
        if state not in ("C", "F"):
            if cpupercent is not None and ncpus_used and cpupercent < ncpus_used * 10:
                note = "â— over-resourced? <10% of CPU used"
        else:
            if used_s < 60:
                note = "short"
            elif cpu_low and ram_low:
                note = "<10% CPU, <10% RAM"
            elif cpu_low:
                note = "<10% CPU"
            elif ram_low:
                note = "<10% RAM"
            if job.get("exit_status", 0) != 0:
                note = "!" + note

        cpu_field = (
            mqstat.Colors.RED + cpu_util_str + mqstat.Colors.ENDC
            if cpu_low and not short_run
            else cpu_util_str
        )
        ram_field = (
            mqstat.Colors.RED + ram_util_str + mqstat.Colors.ENDC
            if ram_low and not short_run
            else ram_util_str
        )

        row_color = ""
        if state == "Q":
            row_color = mqstat.Colors.YELLOW
        elif state in ("C", "F"):
            row_color = (
                mqstat.Colors.GREEN
                if job.get("exit_status", 0) == 0
                else mqstat.Colors.RED
            )
        elif state != "R":
            row_color = ORANGE

        rows.append(
            {
                "job_id": job_id,
                "name": name,
                "used": used,
                "bar": bar,
                "wall": total,
                "waited": waited,
                "cpu": str(cpu),
                "cpu_util": cpu_field,
                "ram": str(ram),
                "ram_util": ram_field,
                "state": state,
                "queue": queue,
                "note": note,
                "raw": job,
                "row_color": row_color,
            }
        )

    if not rows:
        return ["  ".join(headers)], []

    id_w = max(len(headers[0]), max(visible_len(r["job_id"]) for r in rows))
    name_w = max(len(headers[1]), max(visible_len(r["name"]) for r in rows))
    time_w = len(headers[2])
    wall_w = max(len(headers[4]), max(visible_len(r["wall"]) for r in rows))
    wait_w = max(len(headers[5]), max(visible_len(r["waited"]) for r in rows))
    cpu_w = max(len(headers[6]), max(visible_len(r["cpu"]) for r in rows))
    cpuu_w = max(len(headers[7]), max(visible_len(r["cpu_util"]) for r in rows))
    ram_w = max(len(headers[8]), max(visible_len(r["ram"]) for r in rows))
    ramu_w = max(len(headers[9]), max(visible_len(r["ram_util"]) for r in rows))
    state_w = max(len(headers[10]), max(visible_len(r["state"]) for r in rows))
    queue_w = max(len(headers[11]), max(visible_len(r["queue"]) for r in rows))
    note_w = max(len(headers[12]), max(visible_len(r["note"]) for r in rows))

    header_parts = [
        headers[0].ljust(id_w),
        headers[1].ljust(name_w),
        headers[2].ljust(time_w),
        headers[3].ljust(20),
        headers[4].ljust(wall_w),
        headers[5].ljust(wait_w),
        headers[6].rjust(cpu_w),
        headers[7].rjust(cpuu_w),
        headers[8].rjust(ram_w),
        headers[9].rjust(ramu_w),
        headers[10].ljust(state_w),
        headers[11].ljust(queue_w),
        headers[12].ljust(note_w),
    ]
    lines = ["  ".join(header_parts)]

    for r in rows:
        parts = [
            ljust_ansi(r["job_id"], id_w),
            ljust_ansi(r["name"], name_w),
            ljust_ansi(r["used"], time_w),
            r["bar"],
            ljust_ansi(r["wall"], wall_w),
            ljust_ansi(r["waited"], wait_w),
            rjust_ansi(r["cpu"], cpu_w),
            rjust_ansi(r["cpu_util"], cpuu_w),
            rjust_ansi(r["ram"], ram_w),
            rjust_ansi(r["ram_util"], ramu_w),
            ljust_ansi(r["state"], state_w),
            ljust_ansi(r["queue"], queue_w),
            ljust_ansi(r["note"], note_w),
        ]
        coloured_parts = []
        row_colour = r.get("row_color", "")
        for idx, part in enumerate(parts):
            if idx == 3:  # progress column
                coloured_parts.append(part)
            elif row_colour and not ansi_re.search(part):
                coloured_parts.append(row_colour + part + mqstat.Colors.ENDC)
            else:
                coloured_parts.append(part)
        lines.append("  ".join(coloured_parts))

    jobs_out = [r["raw"] for r in rows]
    return lines, jobs_out


def main() -> None:
    parser = argparse.ArgumentParser(description="Interactive job viewer")
    parser.add_argument("--qstat-file", help="Use qstat -f output from file", default=None)
    args = parser.parse_args()

    def get_jobs(include_history: bool = False):
        return mqstat.parse_qstat(path=args.qstat_file, include_history=include_history)

    def _draw(stdscr):
        curses.curs_set(0)
        curses.start_color()
        curses.use_default_colors()
        curses.init_pair(1, curses.COLOR_GREEN, -1)
        curses.init_pair(2, curses.COLOR_RED, -1)
        curses.init_pair(3, curses.COLOR_YELLOW, -1)
        try:
            curses.init_pair(4, 208, -1)  # orange if terminal supports it
        except curses.error:
            curses.init_pair(4, curses.COLOR_YELLOW, -1)
        stdscr.nodelay(True)

        finished = {}
        selected = 1
        lines, job_rows = [], []
        refresh = True

        while True:
            key = stdscr.getch()
            if key == ord("q"):
                break
            elif key in (curses.KEY_DOWN, ord("j")):
                if lines:
                    selected = min(selected + 1, len(lines) - 1)
            elif key in (curses.KEY_UP, ord("k")):
                if lines:
                    selected = max(1, selected - 1)
            elif key in (ord("l"), ord("o"), ord("e")):
                if 0 < selected <= len(job_rows):
                    job = job_rows[selected - 1]
                    if job.get("state") in ("C", "F"):
                        try:
                            stdout_path, stderr_path = mqsub.PbsJobInfo.stdout_and_stderr_paths(job["id"])
                        except Exception:
                            stdout_path = stderr_path = None
                        if key == ord("e"):
                            path = stderr_path
                            suffix = "ER"
                        else:
                            path = stdout_path
                            suffix = "OU"
                        if path and os.path.isdir(path):
                            path = os.path.join(path, f"{job['id']}.{suffix}")
                        if path and os.path.exists(path):
                            curses.endwin()
                            subprocess.call(["less", path])
                            stdscr.clear()
                            curses.curs_set(0)
            elif key == ord("r"):
                refresh = True

            if refresh:
                jobs = get_jobs(include_history=True)
                now = time.time()
                running = []
                for job in jobs:
                    if job.get("queue") == "cpu_inter_exec":
                        continue
                    if job.get("state") in ("C", "F"):
                        ft = job.get("obittime") or job.get("mtime", now)
                        if now - ft <= 24 * 3600:
                            finished[job["id"]] = job
                    else:
                        running.append(job)
                for jid, job in list(finished.items()):
                    ft = job.get("obittime") or job.get("mtime", now)
                    if now - ft > 24 * 3600 or job.get("queue") == "cpu_inter_exec":
                        finished.pop(jid, None)

                all_jobs = running + list(finished.values())
                lines, job_rows = format_jobs(all_jobs, now=now)
                refresh = False

            maxy, maxx = stdscr.getmaxyx()
            stdscr.erase()
            if lines:
                draw_line(stdscr, 0, lines[0], maxx, highlight=True)
                for i, line in enumerate(lines[1: maxy], start=1):
                    draw_line(stdscr, i, line, maxx, highlight=(i == selected))
            stdscr.refresh()
            time.sleep(0.1)

    curses.wrapper(_draw)


if __name__ == "__main__":
    main()

