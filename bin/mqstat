#!/usr/bin/env python3
"""
Cluster Usage Monitor

This script analyzes PBS node information and job statistics to provide a summary of:
1. Overall cluster resource usage with ASCII art visualization
2. Nodes running at high CPU/RAM/GPU utilization (>80%)
3. Current user's resource consumption
4. Resource usage by all users in the "microbiome" group
"""

import subprocess
import re
import os
import pwd
import sys
import grp
import argparse
import time
import unicodedata
from collections import defaultdict
from datetime import datetime

# ANSI color codes
class Colors:
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'


ansi_re = re.compile(r"\x1b\[(\d+)m(.*?)\x1b\[0m")


def strip_ansi(text: str) -> str:
    return ansi_re.sub(r"\2", text)


def _width(ch):
    if unicodedata.combining(ch):
        return 0
    return 2 if unicodedata.east_asian_width(ch) in ("F", "W") else 1


def visible_len(text: str) -> int:
    return sum(_width(ch) for ch in strip_ansi(text))


def ljust_ansi(text: str, width: int) -> str:
    pad = max(width - visible_len(text), 0)
    return text + " " * pad


def rjust_ansi(text: str, width: int) -> str:
    pad = max(width - visible_len(text), 0)
    return " " * pad + text

def run_command(command):
    """Execute a shell command and return the output."""
    process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = process.communicate()
    if process.returncode != 0:
        print(f"Error executing command: {command}")
        print(stderr.decode('utf-8'))
        return None
    return stdout.decode('utf-8')

def parse_pbsnodes_output():
    """Parse the output of `pbsnodes -a` into structured resource usage data."""
    output = run_command("pbsnodes -a")
    if not output:
        raise Exception("Failed to run pbsnodes -a")
    nodes = []
    current_node = {}
    node_name = None

    for line in output.splitlines():
        if not line.strip():  # empty line signifies possible end of a node block
            if current_node and node_name:
                nodes.append(current_node)
                current_node = {}
                node_name = None
            continue

        if not line.startswith(" "):  # new node
            if current_node and node_name:
                nodes.append(current_node)
                current_node = {}
            node_name = line.strip()
            current_node["name"] = node_name
            current_node["used_cpu"] = 0
            current_node["total_cpu"] = 0
            current_node["used_mem"] = 0
            current_node["total_mem"] = 0
            current_node["used_gpu"] = 0
            current_node["total_gpu"] = 0
            current_node["state"] = "unknown"
            continue

        line = line.strip()
        if line.startswith("resources_available.ncpus"):
            current_node["total_cpu"] = int(line.split("=")[-1].strip())
        elif line.startswith("resources_assigned.ncpus"):
            current_node["used_cpu"] = int(line.split("=")[-1].strip())
        elif line.startswith("resources_available.mem"):
            kb = int(line.split("=")[-1].strip().replace("kb", ""))
            current_node["total_mem"] = kb // (1024 * 1024)  # convert to GB
        elif line.startswith("resources_assigned.mem"):
            kb = int(line.split("=")[-1].strip().replace("kb", ""))
            current_node["used_mem"] = kb // (1024 * 1024)  # convert to GB
        elif line.startswith("resources_available.ngpus"):
            current_node["total_gpu"] = int(line.split("=")[-1].strip())
        elif line.startswith("resources_assigned.ngpus"):
            current_node["used_gpu"] = int(line.split("=")[-1].strip())
        elif line.startswith("state"):
            current_node["state"] = line.split("=")[-1].strip()

    # Append last node if needed
    if current_node and node_name:
        nodes.append(current_node)

    # Post-processing for percentages
    for node in nodes:
        total_cpu = node["total_cpu"]
        total_mem = node["total_mem"]
        total_gpu = node["total_gpu"]
        used_cpu = node["used_cpu"]
        used_mem = node["used_mem"]
        used_gpu = node["used_gpu"]

        node["cpu_usage"] = (used_cpu / total_cpu * 100) if total_cpu else 0
        node["ram_usage"] = (used_mem / total_mem * 100) if total_mem else 0
        node["gpu_usage"] = (used_gpu / total_gpu * 100) if total_gpu else 0

        # Derive state
        node["state"] = "free" if used_cpu == 0 else "job-busy"

    return nodes

def parse_qstat(path=None, include_history=False, max_jobs=None):
    """Parse qstat output and merge active and historical jobs."""

    parse_qstat.limit_hit = False
    parse_qstat.hist_limit_hit = False

    def _parse(output):
        jobs = []
        current_job = None
        for line in output.splitlines():
            job_match = re.match(r'^Job Id: (.+)$', line)
            if job_match:
                if current_job:
                    jobs.append(current_job)
                current_job = {'id': job_match.group(1), 'user': None, 'ncpus': 0,
                               'cpu_usage': 0, 'mem_usage': 0, 'gpu_usage': 0,
                               'state': None}
                continue
            if not current_job:
                continue

            name_match = re.search(r'Job_Name = (.+)', line)
            if name_match:
                current_job['name'] = name_match.group(1)

            queue_match = re.search(r'queue = (.+)', line)
            if queue_match:
                current_job['queue'] = queue_match.group(1)

            owner_match = re.search(r'Job_Owner = (.+)@', line)
            if owner_match:
                current_job['user'] = owner_match.group(1)

            state_match = re.search(r'job_state = ([A-Z])', line)
            if state_match:
                current_job['state'] = state_match.group(1)

            qtime_match = re.search(r'qtime = (.+)', line)
            if qtime_match:
                try:
                    dt = datetime.strptime(qtime_match.group(1).strip(), "%a %b %d %H:%M:%S %Y")
                    current_job['qtime'] = int(dt.timestamp())
                except ValueError:
                    pass

            stime_match = re.search(r'stime = (.+)', line)
            if stime_match:
                try:
                    dt = datetime.strptime(stime_match.group(1).strip(), "%a %b %d %H:%M:%S %Y")
                    current_job['start_time'] = int(dt.timestamp())
                except ValueError:
                    pass

            obit_match = re.search(r'obittime = (.+)', line)
            if obit_match:
                try:
                    dt = datetime.strptime(obit_match.group(1).strip(), "%a %b %d %H:%M:%S %Y")
                    current_job['obittime'] = int(dt.timestamp())
                except ValueError:
                    pass

            mtime_match = re.search(r'mtime = (.+)', line)
            if mtime_match:
                try:
                    dt = datetime.strptime(mtime_match.group(1).strip(), "%a %b %d %H:%M:%S %Y")
                    current_job['mtime'] = int(dt.timestamp())
                except ValueError:
                    pass

            if 'resources_used' in line or 'Resource_List' in line:
                cpu_match = re.search(r'Resource_List.ncpus = (\d+)', line)
                if cpu_match:
                    current_job['ncpus'] = int(cpu_match.group(1))

                cpu_match = re.search(r'resources_used.cpupercent = (\d+)', line)
                if cpu_match:
                    current_job['cpupercent'] = int(cpu_match.group(1))

                ncpus_used_match = re.search(r'resources_used.ncpus = (\d+)', line)
                if ncpus_used_match:
                    current_job['ncpus_used'] = int(ncpus_used_match.group(1))

                if 'resources_used.mem' in line:
                    mem_match1 = re.search(r'resources_used.mem = (\d+)kb', line)
                    mem_match2 = re.search(r'resources_used.mem = (\d+)gb', line)
                    mem_match3 = re.search(r'resources_used.mem = 0b', line)
                    if mem_match1:
                        current_job['mem_usage'] = int(mem_match1.group(1))
                    elif mem_match2:
                        current_job['mem_usage'] = int(mem_match2.group(1)) * 1024 * 1024
                    elif mem_match3:
                        current_job['mem_usage'] = 0
                    else:
                        raise Exception("Unknown memory unit from line: " + line)

                mem_req_match = re.search(r'Resource_List.mem = (\d+)([a-zA-Z]+)', line)
                if mem_req_match:
                    val = int(mem_req_match.group(1))
                    unit = mem_req_match.group(2).lower()
                    if unit == 'gb':
                        mem_gb = val
                    elif unit == 'mb':
                        mem_gb = val / 1024
                    elif unit == 'kb':
                        mem_gb = val / (1024 * 1024)
                    else:
                        mem_gb = 0
                    current_job['mem_request_gb'] = mem_gb

                gpu_match = re.search(r'Resource_List.ngpus = (\d+)', line)
                if gpu_match:
                    current_job['ngpus'] = int(gpu_match.group(1))

                walltime_match = re.search(r'resources_used.walltime = (\d+):(\d+):(\d+)', line)
                if walltime_match:
                    h, m, s = map(int, walltime_match.groups())
                    current_job['walltime_used'] = h * 3600 + m * 60 + s
                    if 'walltime_total' in current_job:
                        current_job['walltime'] = current_job['walltime_total'] - current_job['walltime_used']

                cput_match = re.search(r'resources_used.cput = (\d+):(\d+):(\d+)', line)
                if cput_match:
                    h, m, s = map(int, cput_match.groups())
                    current_job['cput_used'] = h * 3600 + m * 60 + s

                vmem_match = re.search(r'resources_used.vmem = (\d+)([a-zA-Z]+)', line)
                if vmem_match:
                    val = int(vmem_match.group(1))
                    unit = vmem_match.group(2).lower()
                    if unit == 'kb':
                        vmem_kb = val
                    elif unit == 'mb':
                        vmem_kb = val * 1024
                    elif unit == 'gb':
                        vmem_kb = val * 1024 * 1024
                    else:
                        vmem_kb = 0
                    current_job['vmem_used_kb'] = vmem_kb

                walltime_match = re.search(r'Resource_List.walltime = (\d+):(\d+):(\d+)', line)
                if walltime_match:
                    h, m, s = map(int, walltime_match.groups())
                    requested_walltime = h * 3600 + m * 60 + s
                    current_job['walltime_total'] = requested_walltime
                    if 'walltime_used' in current_job:
                        current_job['walltime'] = requested_walltime - current_job['walltime_used']
                    else:
                        current_job['walltime'] = requested_walltime
                    current_job['cpu_usage_remaining'] = current_job['ncpus'] * current_job['walltime']
                    if 'ngpus' in current_job:
                        current_job['gpu_usage_remaining'] = current_job['ngpus'] * current_job['walltime']

            exit_match = re.search(r'Exit_status = (\d+)', line)
            if exit_match:
                current_job['exit_status'] = int(exit_match.group(1))

        if current_job:
            jobs.append(current_job)
        return jobs

    if path is None:
        path = os.environ.get("MQSTAT_QSTAT_F")
    if path:
        with open(path) as f:
            output = f.read()
        return _parse(output)

    limit_marker = "AWK_LIMIT_REACHED"
    cmd_active = "qstat -f -t"
    if max_jobs:
        cmd_active = (
            f"{cmd_active} | awk '/Job Id:/{{if (count++=={max_jobs}) {{print \"{limit_marker}\"; exit}}}} {{print}}'"
        )
    active_out = run_command(cmd_active) or ""
    lines = active_out.splitlines()
    if lines and lines[-1] == limit_marker:
        parse_qstat.limit_hit = True
        lines = lines[:-1]
    active_jobs = _parse("\n".join(lines))
    job_dict = {j['id']: j for j in active_jobs}

    if include_history:
        cmd_hist = "qstat -xf -t"
        if max_jobs:
            cmd_hist = (
                f"{cmd_hist} | awk '/Job Id:/{{if (count++=={max_jobs}) {{print \"{limit_marker}\"; exit}}}} {{print}}'"
            )
        hist_out = run_command(cmd_hist) or ""
        lines = hist_out.splitlines()
        if lines and lines[-1] == limit_marker:
            parse_qstat.hist_limit_hit = True
            lines = lines[:-1]
        for job in _parse("\n".join(lines)):
            job_dict.setdefault(job['id'], job)

    return list(job_dict.values())

def get_job_status_counts(jobs):
    """Count jobs by status (running, queued, held)."""
    status_counts = defaultdict(int)
    
    for job in jobs:
        state = job.get('state')
        if state == 'R':
            status_counts['running'] += 1
        elif state == 'Q':
            status_counts['queued'] += 1
        elif state == 'H':
            status_counts['held'] += 1
        else:
            status_counts['other'] += 1
    
    total = sum(status_counts.values())
    running_percent = (status_counts['running'] / total * 100) if total > 0 else 0
    
    return {
        'running': status_counts['running'],
        'queued': status_counts['queued'],
        'held': status_counts['held'],
        'other': status_counts['other'],
        'total': total,
        'running_percent': running_percent
    }

def get_real_name(username):
    """Get the real name for a username."""
    try:
        pwd_entry = pwd.getpwnam(username)
        gecos = pwd_entry.pw_gecos
        real_name = gecos.split(',')[0] if gecos else username
        return real_name if real_name else username
    except KeyError:
        return username

def calculate_cluster_stats(nodes):
    """Calculate summary statistics about cluster usage."""
    total_nodes = len(nodes)
    active_nodes = sum(1 for node in nodes if node['used_cpu'] > 0)
    
    high_cpu_nodes = sum(1 for node in nodes if node['cpu_usage'] >= 80)
    high_ram_nodes = sum(1 for node in nodes if node['ram_usage'] >= 80)
    high_gpu_nodes = sum(1 for node in nodes if node['gpu_usage'] >= 80 and node['total_gpu'] > 0)
    
    total_cpu_cores = sum(node['total_cpu'] for node in nodes)
    used_cpu_cores = sum(node['used_cpu'] for node in nodes)
    
    total_memory_gb = sum(node['total_mem'] for node in nodes)
    used_memory_gb = sum(node['used_mem'] for node in nodes)
    
    total_cpu_only_cores = sum(node['total_cpu'] for node in nodes if node['total_gpu'] == 0)
    used_cpu_only_cores = sum(node['used_cpu'] for node in nodes if node['total_gpu'] == 0)

    total_gpus = sum(node['total_gpu'] for node in nodes)
    used_gpus = sum(node['used_gpu'] for node in nodes)
    
    avg_cpu = sum(node['cpu_usage'] for node in nodes) / total_nodes if total_nodes else 0
    avg_ram = sum(node['ram_usage'] for node in nodes) / total_nodes if total_nodes else 0
    
    # Only include nodes with GPUs in the GPU averages
    gpu_nodes = sum(1 for node in nodes if node['total_gpu'] > 0)
    avg_gpu = sum(node['gpu_usage'] for node in nodes if node['total_gpu'] > 0) / gpu_nodes if gpu_nodes else 0
    
    return {
        'total_nodes': total_nodes,
        'active_nodes': active_nodes,
        'high_cpu_nodes': high_cpu_nodes,
        'high_cpu_percentage': (high_cpu_nodes / total_nodes * 100) if total_nodes else 0,
        'high_ram_nodes': high_ram_nodes,
        'high_ram_percentage': (high_ram_nodes / total_nodes * 100) if total_nodes else 0,
        'high_gpu_nodes': high_gpu_nodes,
        'high_gpu_percentage': (high_gpu_nodes / gpu_nodes * 100) if gpu_nodes else 0,
        'avg_cpu': avg_cpu,
        'avg_ram': avg_ram,
        'avg_gpu': avg_gpu,
        'total_cpu_cores': total_cpu_cores,
        'used_cpu_cores': used_cpu_cores,
        'cpu_utilization': (used_cpu_cores / total_cpu_cores * 100) if total_cpu_cores else 0,
        'total_memory_gb': total_memory_gb,
        'used_memory_gb': used_memory_gb,
        'memory_utilization': (used_memory_gb / total_memory_gb * 100) if total_memory_gb else 0,
        'total_cpu_only_cores': total_cpu_only_cores,
        'used_cpu_only_cores': used_cpu_only_cores,
        'cpu_only_utilization': (used_cpu_only_cores / total_cpu_only_cores * 100) if total_cpu_only_cores else 0,
        'total_gpus': total_gpus,
        'used_gpus': used_gpus,
        'gpu_utilization': (used_gpus / total_gpus * 100) if total_gpus else 0
    }

def get_unix_group_members(group_name):
    """Get all users belonging to a Unix group."""
    try:
        group = grp.getgrnam(group_name)
        return group.gr_mem
    except KeyError:
        print(f"Group '{group_name}' not found")
        return []

def calculate_user_stats(jobs, ignore_interactive=False):
    """Calculate statistics for a specific user or group."""
    if ignore_interactive:
        user_jobs = [job for job in jobs if not job['queue'] in ('cpu_inter_exec','gpu_inter_exec')]
    else:
        user_jobs = jobs
    
    job_status = get_job_status_counts(user_jobs)
    total_jobs = len(user_jobs)
    total_cpu = sum(job['cpu_usage_remaining'] for job in user_jobs)
    total_mem = sum(job['mem_usage'] for job in user_jobs)
    total_gpu = sum(job['gpu_usage'] for job in user_jobs)
    running_cpu = sum(job['ncpus'] for job in user_jobs if job['state'] == 'R')
    running_gpu = sum(job['ngpus'] for job in user_jobs if job['state'] == 'R')
    total_ncpus = sum(job['ncpus'] for job in user_jobs)
    total_ngpus = sum(job['ngpus'] for job in user_jobs)
    total_walltime = sum(job['walltime'] for job in user_jobs)

    # already a %
    # Sometimes get R but no 'cpupercent' key, I guess they are just starting?
    running_cpu_util_total = sum(job['cpupercent'] for job in user_jobs if job['state'] == 'R' and 'cpupercent' in job)
    running_cpu_utilisation = running_cpu_util_total / running_cpu if len(user_jobs) > 0 and running_cpu > 0 else 0

    # speed is roughly running cpus/ Total is cpu_usage_remaining
    eta = total_cpu / running_cpu if running_cpu > 0 else 0
    
    return {
        'job_status': job_status,
        'total_jobs': total_jobs,
        'total_cpu_seconds': total_cpu,
        'total_cpu_hours': total_cpu / 3600,
        'total_memory_kb': total_mem,
        'total_memory_gb': total_mem / (1024 * 1024),
        'total_gpus': total_gpu,
        'avg_cpu_per_job': total_cpu / total_jobs if total_jobs else 0,
        'avg_mem_per_job': total_mem / total_jobs if total_jobs else 0,
        'avg_gpu_per_job': total_gpu / total_jobs if total_jobs else 0,
        'running_cpu': running_cpu,
        'running_gpu': running_gpu,
        'total_ncpus': total_ncpus,
        'total_ngpus': total_ngpus,
        'total_walltime': total_walltime,
        'eta': eta,
        'running_cpu_utilisation': running_cpu_utilisation,
    }

def format_hms(seconds):
    """Format seconds to HH:MM:SS."""
    if seconds is None:
        return ""
    h = seconds // 3600
    m = (seconds % 3600) // 60
    s = seconds % 60
    return f"{h:02}:{m:02}:{s:02}"


def format_hm(seconds):
    """Format seconds to HH:MM."""
    if seconds is None:
        return ""
    h = seconds // 3600
    m = (seconds % 3600) // 60
    return f"{h:02}:{m:02}"


def progress_bar(used, total, width=20):
    """Return a coloured progress bar representing used/total."""
    if not total:
        ratio = 0
    else:
        ratio = used / total
    filled = int(ratio * width)
    bar = "█" * filled + "-" * (width - filled)
    colour = Colors.RED if ratio > 0.8 else Colors.GREEN
    return f"{colour}{bar}{Colors.ENDC}"

def format_time_hours(seconds, descriptor=""):
    """Format seconds into hours, days, months, years or millenia."""
    hours = seconds / 3600
    descriptor = f" {descriptor}" if descriptor else ""
    if hours >= 876000:  # 1 millenia = 876000 hours
        millenia = hours / 876000
        return f"{millenia:.1f}{descriptor} millenia"
    elif hours >= 8760:  # 1 year = 8760 hours
        years = hours / 8760
        return f"{years:.1f}{descriptor} years"
    elif hours >= 730:  # 1 month = 730 hours (approx)
        months = hours / 730
        return f"{months:.1f}{descriptor} months"
    elif hours >= 24:
        days = hours / 24
        return f"{days:.1f}{descriptor} days"
    else:
        return f"{hours:.1f}{descriptor} hours"

def create_ascii_bar(percentage, width=40, reverse=False, colour_text=None):
    """Create an ASCII progress bar with color based on percentage."""
    filled_width = int(percentage / 100 * width)
    empty_width = width - filled_width
    
    if reverse:
        if percentage < 40:
            color = Colors.RED
        elif percentage < 70:
            color = Colors.YELLOW
        else:
            color = Colors.GREEN
    else:
        if percentage < 50:
            color = Colors.GREEN
        elif percentage < 80:
            color = Colors.YELLOW
        else:
            color = Colors.RED

    bar = f"{color}{'█' * filled_width}{Colors.ENDC}{'░' * empty_width} {percentage:.1f}%"
    if colour_text:
        bar = coloured_text(colour_text, color) + bar
    
    return bar

def coloured_text(text, color):
    """Apply color to text."""
    return f"{color}{text}{Colors.ENDC}"

def parse_qusers_output():
    """
    Parse the qusers output and return a dictionary:
    {
        username: {
            'cpus_running': int,
            'cpus_queued': int,
            'gpus_running': int,
            'gpus_queued': int
        },
        ...
    }
    Only use the #run/#queue pairs under CPUs and GPUs, not the jobs section.
    """
    qusers_text = run_command("qusers")

    users = {}
    lines = qusers_text.splitlines()
    # Find the header line with #run and #queue
    for i, line in enumerate(lines):
        if '#run' in line and '#queue' in line:
            header_idx = i
            break
    else:
        return users  # header not found
    header = lines[header_idx]
    # Find all #run and #queue end indices
    def all_col_end_indices(header, colname):
        idxs = []
        pos = 0
        while True:
            pos = header.find(colname, pos)
            if pos == -1:
                break
            idxs.append(pos + len(colname) - 1)
            pos += len(colname)
        return idxs
    run_ends = all_col_end_indices(header, '#run')
    queue_ends = all_col_end_indices(header, '#queue')
    # Use the 2nd and 3rd pairs: CPUs and GPUs
    if len(run_ends) < 3 or len(queue_ends) < 3:
        return users  # not enough columns found
    cpu_run_end = run_ends[1]
    cpu_queue_end = queue_ends[1]
    gpu_run_end = run_ends[2]
    gpu_queue_end = queue_ends[2]
    # Data starts after the header and separator
    for line in lines[header_idx+2:]:
        if not line.strip() or line.startswith('=') or line.startswith('Totals'):
            continue
        username = line[:line.find('|')].strip()
        def extract_int_backwards(line, end_idx):
            if end_idx is None or end_idx >= len(line):
                return 0
            start = end_idx
            while start >= 0 and line[start] != ' ':
                start -= 1
            val = line[start+1:end_idx+1].strip()
            return int(val) if val.isdigit() else 0
        cpus_running = extract_int_backwards(line, cpu_run_end)
        cpus_queued = extract_int_backwards(line, cpu_queue_end)
        gpus_running = extract_int_backwards(line, gpu_run_end)
        gpus_queued = extract_int_backwards(line, gpu_queue_end)
        users[username] = {
            'cpus_running': cpus_running,
            'cpus_queued': cpus_queued,
            'gpus_running': gpus_running,
            'gpus_queued': gpus_queued
        }
    return users

def job_table(jobs, finished=False):
    """Return formatted job table lines."""
    rows = []
    now = time.time()
    for job in jobs:
        queue = job.get('queue', '')
        if queue in ('cpu_inter_exec', 'gpu_inter_exec'):
            continue
        queue = queue.replace('_batch_exec', '')
        job_id = job.get('id', '')
        name = job.get('name', '')
        used_s = job.get('walltime_used', 0)
        total_s = job.get('walltime_total', job.get('walltime', 0))
        used = format_hm(used_s)
        total = format_hm(total_s)
        bar = progress_bar(used_s, total_s)
        cpu = job.get('ncpus', 0)
        cpu_icon = '💪' if cpu > 48 else ''
        ram = int(job.get('mem_request_gb', 0))
        ram_icon = '🧠' if ram > 187 else ''
        state = job.get('state', '')
        note = ''
        cpupercent = job.get('cpupercent')
        ncpus_used = job.get('ncpus_used', job.get('ncpus', 0))
        if cpupercent is not None and ncpus_used and used_s >= 120:
            if cpupercent < ncpus_used * 10:
                note = '❗ <10% of CPU used'

        waited = ''
        qtime = job.get('qtime')
        start_time = job.get('start_time')
        if qtime and start_time:
            waited = format_hm(max(0, start_time - qtime))

        if finished:
            age = ''
            ft = job.get('obittime') or job.get('mtime')
            if ft:
                age = format_hm(max(0, int(now - ft)))
            cput_used = job.get('cput_used', 0)
            cpu_util = 0
            if used_s and cpu > 0:
                cpu_util = cput_used / (used_s * cpu) * 100
            cpu_util_str = f"{int(cpu_util)}%"
            cpu_low = cpu_util < 10

            vmem_kb = job.get('vmem_used_kb', 0)
            ram_util = 0
            if ram:
                ram_util = vmem_kb / (ram * 1024 * 1024) * 100
            ram_util_str = f"{int(ram_util)}%"
            ram_low = ram_util < 10

            if used_s < 60:
                note = 'short'
            elif cpu_low and ram_low:
                note = '<10% CPU, <10% RAM'
            elif cpu_low:
                note = '<10% CPU'
            elif ram_low:
                note = '<10% RAM'
            if job.get('exit_status', 0) != 0:
                note = '!' + note
            row = [
                job_id,
                name,
                used,
                bar,
                total,
                waited,
                age,
                cpu,
                cpu_icon,
                cpu_util_str,
                cpu_low,
                ram,
                ram_icon,
                ram_util_str,
                ram_low,
                queue,
                note,
            ]
        else:
            row = [job_id, name, used, bar, total, cpu, cpu_icon, ram, ram_icon, state, queue, note]
        rows.append(row)

    if finished:
        headers = [
            "job_id",
            "name",
            "time used",
            "progress",
            "walltime",
            "waited",
            "age",
            "CPU",
            "util(%)",
            "RAM(G)",
            "util(%)",
            "queue",
            "note",
        ]
    else:
        headers = ["job_id", "name", "time used", "progress", "walltime", "CPU", "RAM(G)", "state", "queue", "note"]
    if not rows:
        return ["  ".join(headers)]

    id_w = max(len(headers[0]), max(visible_len(r[0]) for r in rows))
    name_w = max(len(headers[1]), max(visible_len(r[1]) for r in rows))
    time_w = len(headers[2])
    wall_w = max(len(headers[4]), max(visible_len(r[4]) for r in rows))
    icon_w = 2  # emoji take two columns

    if finished:
        wait_w = max(len(headers[5]), max(visible_len(r[5]) for r in rows))
        age_w = max(len(headers[6]), max(visible_len(r[6]) for r in rows))
        cpu_w = max(len(headers[7]), max(visible_len(str(r[7])) for r in rows))
        cpuu_w = max(len(headers[8]), max(visible_len(r[9]) for r in rows))
        ram_w = max(len(headers[9]), max(visible_len(str(r[11])) for r in rows))
        ramu_w = max(len(headers[10]), max(visible_len(r[13]) for r in rows))
        queue_w = max(len(headers[11]), max(visible_len(r[15]) for r in rows))
        note_w = max(len(headers[12]), max(visible_len(r[16]) for r in rows))

        def colour(val, low):
            return f"{Colors.RED}{val}{Colors.ENDC}" if low else val

        header_parts = [
            ljust_ansi(headers[0], id_w),
            ljust_ansi(headers[1], name_w),
            ljust_ansi(headers[2], time_w),
            ljust_ansi(headers[3], 20),
            ljust_ansi(headers[4], wall_w),
            ljust_ansi(headers[5], wait_w),
            ljust_ansi(headers[6], age_w),
            rjust_ansi(headers[7], cpu_w) + ' ' * icon_w,
            rjust_ansi(headers[8], cpuu_w),
            rjust_ansi(headers[9], ram_w) + ' ' * icon_w,
            rjust_ansi(headers[10], ramu_w),
            ljust_ansi(headers[11], queue_w),
            ljust_ansi(headers[12], note_w),
        ]
        lines = ["  ".join(header_parts)]
        for r in rows:
            parts = [
                ljust_ansi(r[0], id_w),
                ljust_ansi(r[1], name_w),
                ljust_ansi(r[2], time_w),
                r[3],
                ljust_ansi(r[4], wall_w),
                ljust_ansi(r[5], wait_w),
                ljust_ansi(r[6], age_w),
                rjust_ansi(str(r[7]), cpu_w) + r[8] + ' ' * (icon_w - visible_len(r[8])),
                colour(rjust_ansi(r[9], cpuu_w), r[10]),
                rjust_ansi(str(r[11]), ram_w) + r[12] + ' ' * (icon_w - visible_len(r[12])),
                colour(rjust_ansi(r[13], ramu_w), r[14]),
                ljust_ansi(r[15], queue_w),
                ljust_ansi(r[16], note_w),
            ]
            lines.append("  ".join(parts))
        warnings = []
        if parse_qstat.limit_hit:
            warnings.append(
                f"{Colors.RED}WARNING: qstat -f may not have returned all running/queued jobs; "
                f"increase --max-jobs{Colors.ENDC}"
            )
        if getattr(parse_qstat, "hist_limit_hit", False):
            warnings.append(
                f"{Colors.RED}WARNING: qstat -xf may not have returned all finished jobs; "
                f"increase --max-jobs{Colors.ENDC}"
            )
        lines = warnings + lines
        return lines
    else:
        cpu_w = max(len(headers[5]), max(visible_len(str(r[5])) for r in rows))
        ram_w = max(len(headers[6]), max(visible_len(str(r[7])) for r in rows))
        state_w = max(len(headers[7]), max(visible_len(r[9]) for r in rows))
        queue_w = max(len(headers[8]), max(visible_len(r[10]) for r in rows))
        note_w = max(len(headers[9]), max(visible_len(r[11]) for r in rows))

        header_parts = [
            ljust_ansi(headers[0], id_w),
            ljust_ansi(headers[1], name_w),
            ljust_ansi(headers[2], time_w),
            ljust_ansi(headers[3], 20),
            ljust_ansi(headers[4], wall_w),
            rjust_ansi(headers[5], cpu_w) + ' ' * icon_w,
            rjust_ansi(headers[6], ram_w) + ' ' * icon_w,
            ljust_ansi(headers[7], state_w),
            ljust_ansi(headers[8], queue_w),
            ljust_ansi(headers[9], note_w),
        ]
        lines = ["  ".join(header_parts)]
        for r in rows:
            parts = [
                ljust_ansi(r[0], id_w),
                ljust_ansi(r[1], name_w),
                ljust_ansi(r[2], time_w),
                r[3],
                ljust_ansi(r[4], wall_w),
                rjust_ansi(str(r[5]), cpu_w) + r[6] + ' ' * (icon_w - visible_len(r[6])),
                rjust_ansi(str(r[7]), ram_w) + r[8] + ' ' * (icon_w - visible_len(r[8])),
                ljust_ansi(r[9], state_w),
                ljust_ansi(r[10], queue_w),
                ljust_ansi(r[11], note_w),
            ]
            lines.append("  ".join(parts))
        warnings = []
        if parse_qstat.limit_hit:
            warnings.append(
                f"{Colors.RED}WARNING: qstat -f may not have returned all running/queued jobs; "
                f"increase --max-jobs{Colors.ENDC}"
            )
        if getattr(parse_qstat, "hist_limit_hit", False):
            warnings.append(
                f"{Colors.RED}WARNING: qstat -xf may not have returned all finished jobs; "
                f"increase --max-jobs{Colors.ENDC}"
            )
        return warnings + lines


def list_jobs(jobs):
    """Print job table."""
    for line in job_table(jobs):
        print(line)


def watch_jobs(get_jobs, interval=2):
    """Continuously display job list, updating every interval seconds."""
    import curses
    import time
    import re
    import unicodedata

    finished = {}

    ansi_re = re.compile(r"\x1b\[(\d+)m(.*?)\x1b\[0m")

    def _width(ch):
        if unicodedata.combining(ch):
            return 0
        return 2 if unicodedata.east_asian_width(ch) in ("F", "W") else 1

    def addstr_safe(stdscr, y, x, text, maxx, colour=0):
        width = 0
        out = []
        for ch in text:
            w = _width(ch)
            if x + width + w > maxx - 1:
                break
            out.append(ch)
            width += w
        if out:
            try:
                stdscr.addstr(y, x, "".join(out), colour)
            except curses.error:
                pass
        return width

    def draw_line(stdscr, y, line, maxx):
        """Draw a line that may contain multiple ANSI colour escape codes."""
        x = 0
        last = 0
        for match in ansi_re.finditer(line):
            x += addstr_safe(stdscr, y, x, line[last:match.start()], maxx)
            colour = match.group(1)
            colour_pair = curses.color_pair(1 if colour == '92' else 2)
            x += addstr_safe(stdscr, y, x, match.group(2), maxx, colour_pair)
            last = match.end()
            if x >= maxx - 1:
                break
        if x < maxx - 1 and last < len(line):
            addstr_safe(stdscr, y, x, line[last:], maxx)

    def _draw(stdscr):
        curses.curs_set(0)
        curses.start_color()
        curses.use_default_colors()
        curses.init_pair(1, curses.COLOR_GREEN, -1)
        curses.init_pair(2, curses.COLOR_RED, -1)
        stdscr.nodelay(True)
        while True:
            key = stdscr.getch()
            if key == ord('q'):
                break
            jobs = get_jobs(include_history=True)
            running = []
            now = time.time()
            for job in jobs:
                if job.get('state') in ('C', 'F'):
                    ft = job.get('obittime') or job.get('mtime', now)
                    if now - ft <= 24 * 3600:
                        finished[job['id']] = job
                else:
                    running.append(job)
            # remove finished jobs older than 24h
            for jid, job in list(finished.items()):
                ft = job.get('obittime') or job.get('mtime', now)
                if now - ft > 24 * 3600:
                    finished.pop(jid, None)
            stdscr.erase()
            maxy, maxx = stdscr.getmaxyx()
            half = maxy // 2
            lines_running = job_table(running)
            lines_finished = job_table(list(finished.values()), finished=True)
            for i, line in enumerate(lines_running[:half]):
                draw_line(stdscr, i, line, maxx)
            title_y = half
            stdscr.addstr(title_y, 0, "Finished jobs ===="[:maxx-1])
            for i, line in enumerate(lines_finished[:maxy - half - 1]):
                draw_line(stdscr, title_y + 1 + i, line, maxx)
            stdscr.refresh()
            time.sleep(interval)

    curses.wrapper(_draw)

def main():
    parser = argparse.ArgumentParser(description="Cluster Usage Monitor")
    parser.add_argument("--list", action="store_true", help="Summarise qstat -f output")
    parser.add_argument("--qstat-file", help="Use qstat -f output from file")
    args = parser.parse_args()

    if args.list:
        jobs = parse_qstat(path=args.qstat_file)
        list_jobs(jobs)
        return

    # Get node data
    nodes = parse_pbsnodes_output()

    if not nodes:
        print("Failed to gather node information. Check if pbsnodeinfo is available.")
        return

    # Get qusers data
    qusers_stats = parse_qusers_output()

    # Calculate cluster stats
    cluster_stats = calculate_cluster_stats(nodes)

    # Get job data
    jobs = parse_qstat(path=args.qstat_file)
    
    # Get microbiome group members
    microbiome_members = get_unix_group_members("microbiome")
    # skip admins
    microbiome_members = [member for member in microbiome_members if member not in [
        'thomsonv',
    ]]
    
    # Calculate user stats
    user_stats = calculate_user_stats(jobs, ignore_interactive=True)
    
    print("\n=== YOU ===")
    if user_stats and user_stats['total_jobs'] > 0:
        job_status = user_stats['job_status']
        # ETA
        print(f"ETA: {format_time_hours(user_stats['eta'])}")
        print(f"Walltime remaining: {format_time_hours(user_stats['total_walltime'])}")
        print(f"CPU hours remaining: {format_time_hours(user_stats['total_cpu_seconds'])}")
        print()
        print(f"Jobs: {job_status['running']} of {job_status['total']} running")
        # print(f"Run:   {create_ascii_bar(job_status['running_percent'], reverse=True)}")
        print(f"{create_ascii_bar(job_status['running_percent'], reverse=True, colour_text='Run:   ')}")
        print(f"{create_ascii_bar(user_stats['running_cpu_utilisation'], reverse=True, colour_text='Util:  ')}")

        if job_status['held'] > 0:
            print(f"Jobs held: {job_status['held']} !!")

        # print(f"Jobs: {job_status['total']} total ({job_status['running']} running, {job_status['queued']} queued, {job_status['held']} held, {job_status['running_percent']:.1f}% running)")
        # print(f"CPU:   {create_ascii_bar(user_stats['running_cpu'] / user_stats['total_ncpus'] * 100)}")
        # if user_stats['total_gpus'] > 0:
        #     print(f"GPU:   {create_ascii_bar(user_stats['running_gpu'] / cluster_stats['total_gpus'] * 100)}")
        # print(f"Total memory usage: {user_stats['total_memory_gb']:.2f} GB")
        # if user_stats['total_gpus'] > 0:
        #     print(f"Total GPU usage: {user_stats['total_gpus']} GPUs")
    else:
        print(f"No batch jobs found.")
    
    print("\n\n=== CMR ===")
    # Calculate overall stats
    microbiome_used_cpu = 0
    microbiome_used_gpu = 0
    microbiome_requested_cpu = 0
    for member, stats in qusers_stats.items():
        if member in microbiome_members:
            microbiome_used_cpu += stats['cpus_running']
            microbiome_used_gpu += stats['gpus_running']
            microbiome_requested_cpu += stats['cpus_running'] + stats['cpus_queued']

    microbiome_cpu_percent = microbiome_used_cpu / cluster_stats['total_cpu_cores'] * 100
    microbiome_gpu_percent = microbiome_used_gpu / cluster_stats['total_gpus'] * 100
    microbiome_cpu_requested_percent = microbiome_used_cpu / microbiome_requested_cpu * 100

    print(f"CPU:   {create_ascii_bar(microbiome_cpu_percent)}")
    if cluster_stats['total_gpus'] > 0 and microbiome_used_gpu > 0:
        print(f"GPU:   {create_ascii_bar(microbiome_gpu_percent)}")

    print(f"Requested CPUs: {microbiome_requested_cpu:,} ({microbiome_cpu_requested_percent:.1f}% running)")
    print()

    # Calculate score for each member: cpus_running + 10 * gpus_running
    scored_members = []
    for member in microbiome_members:
        if member in qusers_stats:
            stats = qusers_stats[member]
            score = stats['cpus_running'] + 10 * stats['gpus_running']
            real_name = get_real_name(member)
            scored_members.append((real_name, stats, score))
    # Sort by score descending and print top 5
    sorted_members = sorted(scored_members, key=lambda x: x[2], reverse=True)[:5]
    
    if scored_members:
        # Print table header
        print(f"{'#':<3} {'Member':<20} {'CPU':>12} {'GPU':>10} {'Score':>6}")
        print(f"{'-'*3:<3} {'-'*20:<20} {'-'*12:>12} {'-'*10:>10} {'-'*6:>6}")
        
        # Print each member with proper alignment
        for i, (member, stats, score) in enumerate(sorted_members, 1):
            cpu_display = f"{stats['cpus_running']:,}/{stats['cpus_running'] + stats['cpus_queued']:,}"
            # Show empty space if no GPUs requested
            total_gpus_requested = stats['gpus_running'] + stats['gpus_queued']
            gpu_display = f"{stats['gpus_running']}/{total_gpus_requested}" if total_gpus_requested > 0 else ""
            print(f"{i:<3} {member:<20} {cpu_display:>12} {gpu_display:>10} {score:>6}")
    else:
        print("No jobs for microbiome group members.")
    
    # Print the report
    print("\n\n=== CLUSTER ===")
    
    # ASCII art utilization bars
    print(f"CPU-all:  {create_ascii_bar(cluster_stats['cpu_utilization'])}")
    print(f"RAM-all:  {create_ascii_bar(cluster_stats['memory_utilization'])}")
    if cluster_stats['total_gpus'] > 0:
        print(f"CPU-only: {create_ascii_bar(cluster_stats['cpu_only_utilization'])}")
        print(f"GPU:      {create_ascii_bar(cluster_stats['gpu_utilization'])}")
    print(f'Nodes:    {create_ascii_bar(cluster_stats["active_nodes"]/cluster_stats["total_nodes"]*100)}')
    
    # Num cpus, total ram, gpus
    ram_tb = cluster_stats['total_memory_gb'] / 1024
    print(f"\nTotal {cluster_stats['total_cpu_cores']:,} CPUs, {ram_tb:.1f} TB RAM, {cluster_stats['total_gpus']} GPUs")

    print()

if __name__ == "__main__":
    main()
